[{"content":"LeetCode 876. 链表的中间结点 已收录在 my LeetCode 题目 给定一个带有头结点 head 的非空单链表，返回链表的中间结点。\n如果有两个中间结点，则返回第二个中间结点。\n示例 1 2 3 4 5 6 7 8 9  输入：[1,2,3,4,5]\r输出：此列表中的结点 3 (序列化形式：[3,4,5])\r返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。\r注意，我们返回了一个 ListNode 类型的对象 ans，这样：\rans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.\r输入：[1,2,3,4,5,6]\r输出：此列表中的结点 4 (序列化形式：[4,5,6])\r由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。\r  留意  给定链表的结点数介于 1 和 100 之间。  题解 快慢指针\n方法一 1 2 3 4 5 6 7 8 9 10 11 12 13  # Definition for singly-linked list.\r # class ListNode:\r # def __init__(self, x):\r # self.val = x\r # self.next = None\r class Solution:\rdef middleNode(self, head: ListNode) -\u0026gt; ListNode:\rfast = slow = head\rwhile fast and fast.next:\rfast = fast.next.next\rslow = slow.next\rreturn slow\r  复杂度分析  时间复杂度: O(N) 空间复杂度: O(1)  方法二  太晚了，先占个坑，下次写😂\n 1 2 3 4 5 6 7 8 9 10 11 12  # Definition for singly-linked list.\r # class ListNode:\r # def __init__(self, x):\r # self.val = x\r # self.next = None\r class Solution:\rdef middleNode(self, head: ListNode) -\u0026gt; ListNode:\rans = [head]\rwhile ans[-1].next:\rans.append(ans[-1].next)\rreturn ans[len(ans) // 2]\r  复杂度分析  时间复杂度: O(N) 空间复杂度: O(N)  ","description":"","id":0,"section":"posts","tags":["双指针","leetCodeEasy"],"title":"LeetCode 876","uri":"https://iiijesusiii.github.io/Teletubby/zh/posts/leetcode-876/"},{"content":"LeetCode 1071. 字符串的最大公因子 已收录在 my LeetCode 题目 对于字符串 S 和 T，只有在 S = T + \u0026hellip; + T（T 与自身连接 1 次或多次）时，我们才认定 \u0026ldquo;T 能除尽 S\u0026quot;。\n返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。\n示例 1 2 3 4 5 6 7 8  输入：str1 = \u0026#34;ABCABC\u0026#34;, str2 = \u0026#34;ABC\u0026#34;\r输出：\u0026#34;ABC\u0026#34;\r输入：str1 = \u0026#34;ABABAB\u0026#34;, str2 = \u0026#34;ABAB\u0026#34;\r输出：\u0026#34;AB\u0026#34;\r输入：str1 = \u0026#34;LEET\u0026#34;, str2 = \u0026#34;CODE\u0026#34;\r输出：\u0026#34;\u0026#34;\r  Note  1 \u0026lt;= str1.length \u0026lt;= 1000 1 \u0026lt;= str2.length \u0026lt;= 1000 str1[i] and str2[i] 为大写英文字母  Solution  占个坑 😜，有时间再补\n 1 2 3 4 5  class Solution:\rdef gcdOfStrings(self, str1: str, str2: str) -\u0026gt; str:\rif str1 + str2 != str2 + str1:\rreturn \u0026#39;\u0026#39;\rreturn str1[: math.gcd(len(str1), len(str2))]\r  ","description":"","id":1,"section":"posts","tags":["最大公约数","leetCodeEasy"],"title":"LeetCode 1071","uri":"https://iiijesusiii.github.io/Teletubby/zh/posts/leetcode-1071/"},{"content":"LeetCode 198. 打家劫舍 已收录在 my LeetCode 题目  另一道差不多的题. 面试题 17.16. 按摩师, 这是 力扣原题传送门\n 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下，能够偷窃到的最高金额。\n示例 1 2 3 4 5 6 7 8 9 10 11  输入: [1,2,3,1]\r输出: 4\r解释:\r偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\r偷窃到的最高金额 = 1 + 3 = 4 。\r输入: [2,7,9,3,1]\r输出: 12\r解释:\r偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\r偷窃到的最高金额 = 2 + 9 + 1 = 12 。\r  Solution  先占个坑. 😜\n 1 2 3 4 5 6  class Solution:\rdef rob(self, nums: List[int]) -\u0026gt; int:\rmaxm = pre = 0\rfor num in nums:\rmaxm,pre = max(maxm, num+pre),maxm\rreturn maxm\r  复杂度分析 N 是房屋的数量\n 时间复杂度: O(N) 空间复杂度: O(1)  ","description":"","id":2,"section":"posts","tags":["动态规划","leetCodeEasy"],"title":"LeetCode 198","uri":"https://iiijesusiii.github.io/Teletubby/zh/posts/leetcode-198/"},{"content":"最大公约数  先占个坑 😜\n ","description":"","id":3,"section":"posts","tags":["最大公约数"],"title":"关于最大公约数","uri":"https://iiijesusiii.github.io/Teletubby/zh/posts/math-gcd/"},{"content":"LeetCode 914. 卡牌分组 已收录在 my LeetCode 题目 给定一副牌，每张牌上都写着一个整数。\n此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：\n 每组都有 X 张牌。 组内所有的牌上都写着相同的整数。  仅当你可选的 X \u0026gt;= 2 时返回 true。\n示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  输入：[1,2,3,4,4,3,2,1]\r输出：true\r解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]\r输入：[1,1,1,2,2,2,3,3]\r输出：false\r解释：没有满足要求的分组。\r输入：[1]\r输出：false\r解释：没有满足要求的分组。\r输入：[1,1]\r输出：true\r解释：可行的分组是 [1,1]\rI输入：[1,1,2,2,2,2]\r输出：true\r解释：可行的分组是 [1,1]，[2,2]，[2,2]\r  注意  1 \u0026lt;= deck.length \u0026lt;= 10^4 0 \u0026lt;= deck[i] \u0026lt; 10^4  题解 Counter \u0026amp; GCD(最大公约数), 应该还比较容易理解~\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class Solution:\rdef hasGroupsSizeX(self, deck: List[int]) -\u0026gt; bool:\r# v2.0 没用 Counter 和 gcd 的写法\r d = {}\rfor num in deck:\rd[num] = d.setdefault(num, 0) + 1\rcounter = list(d.values())\rif 1 in counter:\rreturn False\rfor i in range(2, max(counter)+1):\rfor j in counter:\rif j % i != 0:\rbreak\relse:\rreturn True\rreturn False\r# v1.1 比 v1.0 快些\r \u0026#39;\u0026#39;\u0026#39;\rcounter = Counter(deck).values()\rif 1 in counter:\rreturn False\rreturn functools.reduce(math.gcd,counter) \u0026gt;= 2\r\u0026#39;\u0026#39;\u0026#39;\r# v1.0\r \u0026#39;\u0026#39;\u0026#39;\rreturn functools.reduce(math.gcd, Counter(deck).values()) \u0026gt;= 2\r\u0026#39;\u0026#39;\u0026#39;\r  复杂度分析 N 是卡牌的个数，C 是 deck[i] 的取值范围（本题中是10000）。\n求两个数的 最大公约数 的时间复杂度是 O(logC)，最多需要求 N - 1 次。\n 时间复杂度: O(NlogC) 空间复杂度: O(N)  ","description":"","id":4,"section":"posts","tags":["最大公约数","leetCodeEasy"],"title":"LeetCode 914","uri":"https://iiijesusiii.github.io/Teletubby/zh/posts/leetcode-914/"},{"content":" 我的 python 版本 是 3.7\n 如何跳出多层循环 已收录在 python daily tips 自定义异常 1 2 3 4 5 6 7 8 9 10 11  class GetOutOfLoop(Exception):\rpass\rtry:\rfor i in range(5):\rfor j in range(5):\rif i == j == 2:\rraise GetOutOfLoop()\relse:\rprint(i,\u0026#39;----\u0026#39;, j)\rexcept GetOutOfLoop:\rpass\r  将多层循环封装成函数 1 2 3 4 5 6 7 8 9  def test():\rfor i in range(5):\rfor j in range(5):\rif i == j == 2:\rreturn\relse:\rprint(i,\u0026#39;----\u0026#39;, j)\rtest()\r  使用 for-else 语句 更多关于如何使用 for-else 语句。\n1 2 3 4 5 6 7 8 9 10 11 12 13  for i in range(5):\rfor j in range(5):\rfor k in range(5):\rif i == j == k == 3:\rbreak # break k loop\r else: print(i, \u0026#39;----\u0026#39;, j, \u0026#39;----\u0026#39;, k)\relse: #1 else1\r continue\rbreak #1 break j loop\r else: #2 else2\r continue\rbreak #2 break i loop\r   ","description":"","id":5,"section":"posts","tags":["python"],"title":"Python 如何跳出多层循环","uri":"https://iiijesusiii.github.io/Teletubby/zh/posts/python-break-loop/"},{"content":"瀑布联句  李枕，香严闲禅师\n 千岩万壑不辞劳，远看方知出处高。\n溪涧岂能留得住，终归大海作波涛。\n作者简介 李忱（810— 859年），即唐宣宗，宪宗第十三子。初名怡，即位日改名忱。穆宗长庆元年（821年）封光王，武宗会昌六年（846年）即位，改元年号大中。卒谥文献。\n香严闲禅师：庐山上高僧。\n创作背景 此诗具体创作时间未知。唐宣宗李忱因母亲地位卑下，侄子文宗、武宗常把他当成小丑戏耍。他用无言对待各种加诸于他的猜忌、打击，在艰难困苦中默默地忍受，但他并没有消沉。他逃避人世做了僧人。游行江淮，寻访名山禅院，一日，遇黄檗禅师，（据《佛祖统纪》应为香严闲禅师。因宣宗上庐山时黄檗在海昌，不可能联句）并与之同行，\u0026ldquo;因观瀑布。黄檗曰：‘我咏此得一联，而下韵不接。’宣宗曰：‘ 当为续成之。’\u0026ldquo;遂有《瀑布联句》。\n赏析 此诗的作者是一位皇帝和一位僧侣。禅师作前两句，有暗射宣宗当时处境用意；宣宗续后两句，则寄寓不甘落寞、思有作为的情怀。这样一首托物言志的诗，描绘了冲决一切、气势磅礴的瀑布的艺术形象，富有激情，读来使人激奋，受到鼓舞，艺术形象往往大于作者思想，这也是一个显例。……\n参考  品诗文网-瀑布联句\n百度百科-瀑布联句\n ","description":"","id":6,"section":"posts","tags":["李枕"],"title":"#2 《瀑布联句》","uri":"https://iiijesusiii.github.io/Teletubby/zh/posts/poems-day-2/"},{"content":"宣州谢昭楼饯别校书叔云  李白\n 弃我去者，昨日之日不可留。\n乱我心者，今日之日多烦忧。\n长风万里送秋雁，对此可以酣高楼。\n蓬莱文章建安骨，中间小谢又清发。\n俱怀逸兴壮思飞，欲上青天揽明月。\n抽刀断水水更流，举杯消愁愁更愁。\n人生在世不称意，明朝散发弄扁舟。\n作者简介 李白（701年－762年） ，字太白，号青莲居士，又号\u0026quot;谪仙人\u0026rdquo;，唐代伟大的浪漫主义诗人，被后人誉为\u0026quot;诗仙\u0026rdquo;，与杜甫并称为\u0026quot;李杜\u0026rdquo;，为了与另两位诗人李商隐与杜牧即\u0026quot;小李杜\u0026quot;区别，杜甫与李白又合称\u0026quot;大李杜\u0026rdquo;。\n创作背景 这首诗作于安史之乱前不久。大约是在公元753年（天宝十二载,天宝末年）的秋天，李白来到宣州，客居宣州不久，他的一位故人李云行至此，很快又要离开，李白陪他登谢脁楼，设宴送行。宣州谢脁楼（一称谢脁楼或谢公楼，唐末改称叠嶂楼）是南齐诗人谢脁任宣城（今安徽省宣城县）太守时所建。李白曾多次登临，并写过一首《秋登宣城谢脁北楼》。\n赏析 这是一首饯别抒怀诗。在诗中，诗人感怀万端，既满怀豪情逸兴，又时时掩抑不住郁闷与不平，感情回复跌宕，一波三折，表达了自己遗世高蹈的豪迈情怀。……\n参考  李白诗歌网-宣州谢脁楼饯别校书叔云\n品诗文网-宣州谢脁楼饯别校书叔云\n ","description":"","id":7,"section":"posts","tags":["李白"],"title":"#1 《宣州谢昭楼饯别校书叔云》","uri":"https://iiijesusiii.github.io/Teletubby/zh/posts/poems-day-1/"},{"content":"LeetCode 300. 最长上升子序列 已收录在 my LeetCode 题目 给定一个无序的整数数组，找到其中最长上升子序列的长度。\n示例 1 2 3 4  输入: [10,9,2,5,3,7,101,18]\r输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。\r  注意  可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(N^2)。  进阶 你能将算法的时间复杂度降低到 O(NlogN) 吗?\n题解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Solution:\rdef lengthOfLIS(self, nums: List[int]) -\u0026gt; int:\r\u0026#39;\u0026#39;\u0026#39;numsLen = len(nums)\rif numsLen \u0026lt; 2:\rreturn numsLen\u0026#39;\u0026#39;\u0026#39;\rdp = []\rans = 0\rfor n in nums:\rif ans \u0026lt; 1 or n \u0026gt; dp[-1]:\rdp.append(n)\rans += 1\relse:\rlow, high = 0, ans - 1\rwhile low \u0026lt; high:\rmid = (low + high) // 2\rif dp[mid] \u0026gt;= n:\rhigh = mid\relse:\rlow = mid + 1\rdp[high] = n\rreturn ans\r  复杂度分析 nums 的长度为 N ，依次用数组中的元素去更新 dp，而更新 dp 数组时需要进行二分查找 (时间复杂度为 O(logN))。\n 时间复杂度: O(NlogN) 空间复杂度: O(N)  ","description":"","id":8,"section":"posts","tags":["动态规划","二分查找","leetCodeMed"],"title":"LeetCode 300","uri":"https://iiijesusiii.github.io/Teletubby/zh/posts/leetcode-300/"},{"content":"LeetCode 945. 使数组唯一的最小增量 已收录在 my LeetCode 题目 给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。\n返回使 A 中的每个值都是唯一的最少操作次数。\n示例 1 2 3 4 5 6 7 8 9 10  输入：[1,2,2]\r输出：1\r解释：\r经过一次 move 操作，数组将变为 [1, 2, 3]。\r输入：[3,2,1,2,1,7]\r输出：6\r解释：\r经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。\r可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。\r  留意  0 \u0026lt;= A.length \u0026lt;= 40000 0 \u0026lt;= A[i] \u0026lt; 40000  题解 方法一 贪心算法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution:\rdef minIncrementForUnique(self, A: List[int]) -\u0026gt; int:\rif not A:\rreturn 0\rA.sort()\rp = A[0]\rcnt = 0\rfor i in A[1:]:\rif p \u0026gt;= i:\rp += 1\rcnt += p - i\relse:\rp = i\rreturn cnt\r  复杂度分析  时间复杂度: O(NlogN) 空间复杂度: O(N)  方法二 线性探测（含路径压缩）\n 待补坑\n 复杂度分析  时间复杂度: O(N) 空间复杂度: O(N)  ","description":"","id":9,"section":"posts","tags":["贪心算法","leetCodeMed"],"title":"LeetCode 945","uri":"https://iiijesusiii.github.io/Teletubby/zh/posts/leetcode-945/"},{"content":" My python version is 3.7\n timeit - 测量小代码片段的执行时间 已收录在 python daily tips 该模块提供了一种简单的方法来计算一小段 Python 代码的耗时。它避免了许多用于测量执行时间的常见陷阱。\n这可以通过 命令行界面 和 Python接口 来实现。\n这里只讨论 python接口.\npython 接口 该模块定义了三个便利函数和一个公共类：\n timeit.timeit(stmt='pass\u0026rsquo;, setup='pass\u0026rsquo;, timer=, number=1000000, globals=None) timeit.repeat(stmt='pass\u0026rsquo;, setup='pass\u0026rsquo;, timer=, repeat=5, number=1000000, globals=None) timeit.default_timer() class timeit.Timer(stmt='pass\u0026rsquo;, setup='pass\u0026rsquo;, timer=, globals=None)  timeit.timeit() 使用给定语句、 setup 代码和 timer 函数创建一个 Timer 实例，并执行 number 次其 timeit() 方法。可选的 globals 参数指定用于执行代码的命名空间。\n 在 3.5 版更改: 添加可选参数 globals。  timeit.repeat() 使用给定语句、 setup 代码和 timer 函数创建一个 Timer 实例，并使用给定的 repeat 计数和 number 执行运行其 repea() 方法。可选的 globals 参数指定用于执行代码的命名空间。\n 在 3.5 版更改: 添加可选参数 globals。 在 3.7 版更改: repeat 的默认值由 3 更改为 5。  timeit.default_timer() 默认的计时器，总是 time.perf_counter。\n 在 3.3 版更改: time.perf_counter() 现在是 默认计时器。  class timeit.Timer 用于小代码片段的计数执行速度的类。\n构造函数接受一个将计时的语句、一个用于设置的附加语句和一个定时器函数。两个语句都默认为 \u0026lsquo;pass\u0026rsquo; ；计时器函数与平台有关（请参阅模块文档字符串）。 stmt 和 setup 也可能包含多个以 ; 或换行符分隔的语句，只要它们不包含多行字符串文字即可。该语句默认在 timeit 的命名空间内执行；可以通过将命名空间传递给 globals 来控制此行为\n要测量第一个语句的执行时间，请使用 timeit() 方法。 repeat() 和 autorange() 方法是方便的方法来调用 timeit() 多次。\nsetup 的执行时间从总体计时执行中排除。\nstmt 和 setup 参数也可以使用不带参数的可调用对象。这将在一个计时器函数中嵌入对它们的调用，然后由 timeit() 执行。请注意，由于额外的函数调用，在这种情况下，计时开销会略大一些。\n 在 3.5 版更改: 添加可选参数 globals。  timeit(number=1000000) 执行 number 次主要语句。这将执行一次 setup 语句，然后返回执行主语句多次所需的时间，以秒为单位测量为浮点数。参数是通过循环的次数，默认为一百万。要使用的主语句、 setup 语句和 timer 函数将传递给构造函数。\n 注意\n默认情况下， timeit() 暂时关闭 garbage collection 。这种方法的优点在于它使独立时序更具可比性。缺点是GC可能是所测量功能性能的重要组成部分。如果是这样，可以在 setup 字符串中的第一个语句重新启用GC。例如:\ntimeit.Timer('for i in range(10): oct(i)', 'gc.enable()').timeit()\n autorange(callback=None) 自动决定调用多少次 timeit()。\n这是一个便利函数，它反复调用 timeit() ，以便总时间 \u0026gt;= 0.2 秒，返回最终（循环次数，循环所用的时间）。它调用 timeit() 的次数以序列 1, 2, 5, 10, 20, 50, \u0026hellip; 递增，直到所用的时间至少为0.2秒。\n如果给出 callback 并且不是 None ，则在每次试验后将使用两个参数调用它： callback(number, time_taken)。\n 3.6 版新功能。  repeat(repeat=5, number=1000000) 调用 timeit() 几次。\n这是一个方便的函数，它反复调用 timeit() ，返回结果列表。第一个参数指定调用 timeit() 的次数。第二个参数指定 timeit() 的 number 参数。\n Note\n从结果向量计算并报告平均值和标准差这些是很诱人的。但是，这不是很有用。在典型情况下，最低值给出了机器运行给定代码段的速度的下限；结果向量中较高的值通常不是由Python的速度变化引起的，而是由于其他过程干扰你的计时准确性。所以结果的 min() 可能是你应该感兴趣的唯一数字。之后，你应该看看整个向量并应用常识而不是统计。\n  在 3.7 版更改: repeat 的默认值由 3 更改为 5。  print_exc(file=None) 帮助程序从计时代码中打印回溯。\n典型使用:\n1 2 3 4 5  t = Timer(...) # outside the try/except\r try:\rt.timeit(...) # or t.repeat(...)\r except Exception:\rt.print_exc()\r  与标准回溯相比，优势在于将显示已编译模板中的源行。可选的 file 参数指向发送回溯的位置；它默认为 sys.stderr 。\n示例 基本示例\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; import timeit\r\u0026gt;\u0026gt;\u0026gt; timeit.timeit(\u0026#39;\u0026#34;-\u0026#34;.join(str(n) for n in range(100))\u0026#39;, number=10000)\r0.3018611848820001\r\u0026gt;\u0026gt;\u0026gt; timeit.timeit(\u0026#39;\u0026#34;-\u0026#34;.join([str(n) for n in range(100)])\u0026#39;, number=10000)\r0.2727368790656328\r\u0026gt;\u0026gt;\u0026gt; timeit.timeit(\u0026#39;\u0026#34;-\u0026#34;.join(map(str, range(100)))\u0026#39;, number=10000)\r0.23702679807320237\r  也可以传出一个可调用对象:\n1 2  \u0026gt;\u0026gt;\u0026gt; timeit.timeit(lambda: \u0026#34;-\u0026#34;.join(map(str, range(100))), number=10000)\r0.19665591977536678\r  可以提供一个在开头只执行一次的 setup 语句：\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; import timeit\r\u0026gt;\u0026gt;\u0026gt; timeit.timeit(\u0026#39;char in text\u0026#39;, setup=\u0026#39;text = \u0026#34;sample string\u0026#34;; char = \u0026#34;g\u0026#34;\u0026#39;)\r0.41440500499993504\r\u0026gt;\u0026gt;\u0026gt; timeit.timeit(\u0026#39;text.find(char)\u0026#39;, setup=\u0026#39;text = \u0026#34;sample string\u0026#34;; char = \u0026#34;g\u0026#34;\u0026#39;)\r1.7246671520006203\r  使用 Timer 类及其方法可以完成同样的操作:\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; import timeit\r\u0026gt;\u0026gt;\u0026gt; t = timeit.Timer(\u0026#39;char in text\u0026#39;, setup=\u0026#39;text = \u0026#34;sample string\u0026#34;; char = \u0026#34;g\u0026#34;\u0026#39;)\r\u0026gt;\u0026gt;\u0026gt; t.timeit()\r0.3955516149999312\r\u0026gt;\u0026gt;\u0026gt; t.repeat()\r[0.40183617287970225, 0.37027556854118704, 0.38344867356679524, 0.3712595970846668, 0.37866875250654886]\r  以下示例显示如何计算包含多行的表达式。 在这里我们对比使用 hasattr() 与 try/except 的开销来测试缺失与提供对象属性:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  \u0026gt;\u0026gt;\u0026gt; import timeit\r\u0026gt;\u0026gt;\u0026gt; # attribute is missing\r \u0026gt;\u0026gt;\u0026gt; s = \u0026#34;\u0026#34;\u0026#34;\\\r... try:\r... str.__bool__\r... except AttributeError:\r... pass\r... \u0026#34;\u0026#34;\u0026#34;\r\u0026gt;\u0026gt;\u0026gt; timeit.timeit(stmt=s, number=100000)\r0.9138244460009446\r\u0026gt;\u0026gt;\u0026gt; s = \u0026#34;if hasattr(str, \u0026#39;__bool__\u0026#39;): pass\u0026#34;\r\u0026gt;\u0026gt;\u0026gt; timeit.timeit(stmt=s, number=100000)\r0.5829014980008651\r\u0026gt;\u0026gt;\u0026gt;\r\u0026gt;\u0026gt;\u0026gt; # attribute is present\r \u0026gt;\u0026gt;\u0026gt; s = \u0026#34;\u0026#34;\u0026#34;\\\r... try:\r... int.__bool__\r... except AttributeError:\r... pass\r... \u0026#34;\u0026#34;\u0026#34;\r\u0026gt;\u0026gt;\u0026gt; timeit.timeit(stmt=s, number=100000)\r0.04215312199994514\r\u0026gt;\u0026gt;\u0026gt; s = \u0026#34;if hasattr(int, \u0026#39;__bool__\u0026#39;): pass\u0026#34;\r\u0026gt;\u0026gt;\u0026gt; timeit.timeit(stmt=s, number=100000)\r0.08588060699912603\r  要让 timeit 模块访问你定义的函数，你可以传递一个包含 import 语句的 setup 参数:\n1 2 3 4 5 6 7  def test():\r\u0026#34;\u0026#34;\u0026#34;Stupid test function\u0026#34;\u0026#34;\u0026#34;\rL = [i for i in range(100)]\rif __name__ == \u0026#39;__main__\u0026#39;:\rimport timeit\rprint(timeit.timeit(\u0026#34;test()\u0026#34;, setup=\u0026#34;from __main__ import test\u0026#34;))\r  另一种选择是将 globals() 传递给 globals 参数，这将导致代码在当前的全局命名空间中执行。这比单独指定 import 更方便\n1 2 3 4 5 6 7 8 9  def f(x):\rreturn x**2\rdef g(x):\rreturn x**4\rdef h(x):\rreturn x**8\rimport timeit\rprint(timeit.timeit(\u0026#39;[func(42) for func in (f,g,h)]\u0026#39;, globals=globals()))\r   参考 timeit - 测量小代码片段的执行时间\n ","description":"","id":10,"section":"posts","tags":["python"],"title":"Python timeit","uri":"https://iiijesusiii.github.io/Teletubby/zh/posts/python-timeit/"},{"content":" 我的 python 版本 是 3.7\n python sorted() (内置方法) 已收录在 python daily tips  译自: Python sorted()\n sorted() 函数以迭代方式返回排序列表。\nsorted() 函数以特定顺序（\u0026quot;升序\u0026ldquo;或\u0026rdquo;降序\u0026quot;）对给定的可迭代元素进行排序。\nsorted() 的语法是:\nsorted(iterable, key=None, reverse=False)\nsorted() 参数 sorted() 最多能接受三个参数\n iterable - 序列（字符串，元组，列表）或集合（集合，字典，冻结集合）或任何其他迭代器。 reverse (Optional) - 如果为 True ，则排序的列表会被反转（降序输出）。如果未说明，则表示默认 False。 key (Optional) - 用来作为比较排序的 key 的功能。默认为 None  示例 1: 对字符串、列表和元组进行排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14  # vowels list\r py_list = [\u0026#39;e\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;i\u0026#39;]\rprint(sorted(py_list))\r# [\u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;u\u0026#39;]\r # string  py_string = \u0026#39;Python\u0026#39;\rprint(sorted(py_string))\r# [\u0026#39;P\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;y\u0026#39;]\r # vowels tuple\r py_tuple = (\u0026#39;e\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;i\u0026#39;)\rprint(sorted(py_tuple))\r# [\u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;u\u0026#39;]\r   示例 2: 对集合(set)、字典(dict)和 frozenset 进行降序排序 sorted() 函数接受 reverse 参数作为可选参数。\n设置 reverse = True 将可迭代对象降序排序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  # set\r py_set = {\u0026#39;e\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;i\u0026#39;}\rprint(sorted(py_set, reverse = True))\r# [\u0026#39;u\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;a\u0026#39;]\r # dictionary\r py_dict = {\u0026#39;e\u0026#39;: 1, \u0026#39;a\u0026#39;: 2, \u0026#39;u\u0026#39;: 3, \u0026#39;o\u0026#39;: 4, \u0026#39;i\u0026#39;: 5}\rprint(sorted(py_dict, reverse = True))\r# [\u0026#39;u\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;a\u0026#39;]\r # frozen set\r frozen_set = frozenset((\u0026#39;e\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;i\u0026#39;))\rprint(sorted(frozen_set, reverse = True))\r# [\u0026#39;u\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;a\u0026#39;]\r   Python sorted() 中的 key 参数 sorted() 可以接受 key 函数 作为一个可选参数来实现自定义排序。\n根据 key 函数，可以对你给定的可迭代对象进行排序。\nEg.sorted(iterable, key=len)\n这样就可以对 iterable 根据其内部元素的长度进行从小到大进行排序。\n示例 3: 使用带 key 参数的 sorted() 对列表进行排序 1 2 3 4 5 6 7 8 9 10 11 12 13  # take the second element for sort\r def take_second(elem):\rreturn elem[1]\r# random list\r random = [(2, 2), (3, 4), (4, 1), (1, 3)]\r# sort list with key\r sorted_list = sorted(random, key = take_second)\r# print list\r print(\u0026#39;Sorted list:\u0026#39;, sorted_list)\r# Sorted list: [(4, 1), (2, 2), (1, 3), (3, 4)]\r   Note 还有一个和 sorted() 执行方式差不多的函数\u0026ndash; sort()。它们唯一的区别就是，sort() 方法不会返回任何值，并且会更改原始列表。\n","description":"","id":11,"section":"posts","tags":["python"],"title":"Python sorted()","uri":"https://iiijesusiii.github.io/Teletubby/zh/posts/python-sorted/"},{"content":"贝祖等式 这里只是简单的叙述 贝祖定理(裴蜀定理)。\n 参考 贝祖等式\n参考 裴蜀定理\n 对任何整数 a，b 和它们的最大公约数 d，关于未知数 x 和 y 的线性不定方程（称为裴蜀等式，亦贝祖等式）：若 a，b 是整数,且gcd(a,b)=d，那么对于任意的整数 x，y，ax + by都一定是 d 的倍数。\n特别地，一定存在整数 x，y 使 ax + by = d 成立。\n它的一个重要推论是：a，b 互质的充要条件是存在整数 x，y 使 ax + by = 1。\n在数论中，裴蜀等式（英语：Bézout\u0026rsquo;s identity）或裴蜀定理（Bézout\u0026rsquo;s lemma）是一个关于最大公约数（或最大公约式）的定理。裴蜀定理得名于法国数学家艾蒂安·裴蜀，说明了对任何整数 a、b 和 m，关于未知数 x 和 y 的线性丢番图方程（称为裴蜀等式）：\nax + by = m\n有解当且仅当 m 是 d 的倍数。裴蜀等式有解时必然有无穷多个整数解，每组解x、y都称为裴蜀数，可用辗转相除法求得 或 更相减损术。\n例如，12 和 42 的最大公因子是6，则方程 12x + 42y = 6 有解。事实上有 (-3)×12 + 1×42 = 6 及 4×12 + (-1）×42 = 6。\n裴蜀等式 也可以用来给最大公约数定义：d 其实就是最小的可以写成 ax + by 形式的正整数。这个定义的本质是整环中\u0026rdquo;理想\u0026ldquo;的概念。因此对于多项式整环也有相应的裴蜀定理。\n历史 历史上首先证明关于整数的裴蜀定理的并不是裴蜀，而是17世纪初的法国数学家克劳德-加斯帕·巴歇·德·梅齐里亚克。他在于1624年发表的著作《有关整数的令人快乐与惬意的问题集》（Problèmes plaisants et délectables qui se font par les nombres）第二版中给出了问题的描述和证明[1]。\n然而，裴蜀推广了梅齐里亚克的结论，特别是探讨了多项式中的裴蜀等式，并给出了相应的定理和证明[2]。\n注释 [1] 原版的网上版本（法文）\n[2] 证明的网上版本（法文）\n","description":"","id":12,"section":"posts","tags":["贝祖定理"],"title":"贝祖等式","uri":"https://iiijesusiii.github.io/Teletubby/zh/posts/math-bezu-identity/"},{"content":"LeetCode 67. 二进制求和 已收录在 my LeetCode 题目 给定两个二进制字符串，返回他们的和（用二进制表示）。\n输入为 非空 字符串且只包含数字 1 和 0。\n示例 1 2 3 4 5  输入: a = \u0026#34;11\u0026#34;, b = \u0026#34;1\u0026#34;\r输出: \u0026#34;100\u0026#34;\r输入: a = \u0026#34;1010\u0026#34;, b = \u0026#34;1011\u0026#34;\r输出: \u0026#34;10101\u0026#34;\r  题解 方法一 无需多说，哈哈哈 😂\n1 2 3  class Solution:\rdef addBinary(self, a: str, b: str) -\u0026gt; str:\rreturn bin(int(a, 2) + int(b, 2))[2:]\r  方法二 用 哈希表.\n 两个输入串a, b中，将短串 左填充 \u0026lsquo;0\u0026rsquo; 直到长度和另一个串一样多。 创建一个 哈希表 用来记录这两个二进制串按位相加的结果的所有情况。表中每个键都有三个字符，从左到右分别表示 a中的字符，b中的字符和上一位的进位 (carry)。每个键的值有两个字符，分别表示当前位的运算结果 (ch) 和进位 (carry)。 ans += ch 并且将 ans 逆序 return。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class Solution:\rdef addBinary(self, a: str, b: str) -\u0026gt; str:\ralen = len(a)\rblen = len(b)\rif alen \u0026gt; blen:\rb = b.zfill(alen)\relse:\ra = a.zfill(blen)\rans = \u0026#39;\u0026#39;\rcarry = \u0026#39;0\u0026#39;\rhm = {\r\u0026#39;000\u0026#39; : (\u0026#39;0\u0026#39;, \u0026#39;0\u0026#39;),\r\u0026#39;101\u0026#39; : (\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;),\r\u0026#39;011\u0026#39; : (\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;),\r\u0026#39;110\u0026#39; : (\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;),\r\u0026#39;001\u0026#39; : (\u0026#39;1\u0026#39;, \u0026#39;0\u0026#39;),\r\u0026#39;100\u0026#39; : (\u0026#39;1\u0026#39;, \u0026#39;0\u0026#39;),\r\u0026#39;010\u0026#39; : (\u0026#39;1\u0026#39;, \u0026#39;0\u0026#39;),\r\u0026#39;111\u0026#39; : (\u0026#39;1\u0026#39;, \u0026#39;1\u0026#39;),\r\u0026#39; 0\u0026#39; : (\u0026#39;\u0026#39;, \u0026#39;\u0026#39;),\r\u0026#39; 1\u0026#39; : (\u0026#39;1\u0026#39;, \u0026#39;\u0026#39;)\r}\rfor ach,bch in zip(a[::-1] + \u0026#39; \u0026#39;, b[::-1] + \u0026#39; \u0026#39;):\rtmp = ach + bch + carry\rch, carry = hm[tmp]\rans += ch\rreturn ans[::-1]\r  方法三 我们都知道 Python 中的字符串是一个 不可变对象。其所指对象的值是不能被修改的。\n因此如果你重新给它赋值，它将会创建一个新的字符串对象。这样的话，执行效率会有一定程度的降低。\n所以下面这段代码在方法二的基础上做了一点修改，将 carry 的初始值改为 ''，并且当进位为 ‘0’ 时也改为 ''。\n这样代码的运行速度可能会少有提高。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Solution:\rdef addBinary(self, a: str, b: str) -\u0026gt; str:\ralen = len(a)\rblen = len(b)\rif alen \u0026gt; blen:\rb = b.zfill(alen)\relse:\ra = a.zfill(blen)\rcarry = ans = \u0026#39;\u0026#39;\rhm = {\r\u0026#39;00\u0026#39; : (\u0026#39;0\u0026#39;, \u0026#39;\u0026#39;),\r\u0026#39;101\u0026#39; : (\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;),\r\u0026#39;011\u0026#39; : (\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;),\r\u0026#39;11\u0026#39; : (\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;),\r\u0026#39;001\u0026#39; : (\u0026#39;1\u0026#39;, \u0026#39;\u0026#39;),\r\u0026#39;10\u0026#39; : (\u0026#39;1\u0026#39;, \u0026#39;\u0026#39;),\r\u0026#39;01\u0026#39; : (\u0026#39;1\u0026#39;, \u0026#39;\u0026#39;),\r\u0026#39;111\u0026#39; : (\u0026#39;1\u0026#39;, \u0026#39;1\u0026#39;),\r\u0026#39; \u0026#39; : (\u0026#39;\u0026#39;, \u0026#39;\u0026#39;),\r\u0026#39; 1\u0026#39; : (\u0026#39;1\u0026#39;, \u0026#39;\u0026#39;)\r}\rfor ach,bch in zip(a[::-1] + \u0026#39; \u0026#39;, b[::-1] + \u0026#39; \u0026#39;):\rtmp = ach + bch + carry\rch, carry = hm[tmp]\rans += ch\rreturn ans[::-1]\r  ","description":"","id":13,"section":"posts","tags":["哈希表","leetCodeEasy"],"title":"LeetCode 67","uri":"https://iiijesusiii.github.io/Teletubby/zh/posts/leetcode-67/"},{"content":"LeetCode 面试题 01.06. 字符串压缩 已收录在 my LeetCode 题目 字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。\n比如，字符串aabcccccaaa会变为a2b1c5a3。若\u0026quot;压缩\u0026quot;后的字符串没有变短，则返回原先的字符串。\n你可以假设字符串中只包含大小写英文字母（a至z）。\n示例 1 2 3 4 5 6 7  输入：\u0026#34;aabcccccaaa\u0026#34;\r输出：\u0026#34;a2b1c5a3\u0026#34;\r输入：\u0026#34;abbccd\u0026#34;\r输出：\u0026#34;abbccd\u0026#34;\r解释：\r\u0026#34;abbccd\u0026#34; 压缩后为\u0026#34;a1b2c2d1\u0026#34;，比原字符串长度更长。\r  留意 字符串长度在[0, 50000]范围内。\n题解 使用 f-string 会更快。\n如果你还不清楚怎么用f-string，可以点击这里获取更多帮助。\n在for循环内部添加判断语句，比较 当前记录的字符的个数-1 charsCnt - 1 与 字符串S的一半串长 len(S) \u0026gt;\u0026gt; 1, 若大于则直接 return S。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution:\rdef compressString(self, S: str) -\u0026gt; str:\rn = len(S)\rif n \u0026lt;= 2:\rreturn S\rcnt = charsCnt = 1\rchar = S[0]\rans = \u0026#39;\u0026#39;\rn = n \u0026gt;\u0026gt; 1\rfor ch in S[1:] + \u0026#39; \u0026#39;:\rif ch != char:\rans += f\u0026#34;{char}{cnt}\u0026#34;\rchar = ch\rcnt = 1\rcharsCnt += 1\relse:\rcnt += 1\rif charsCnt - 1 \u0026gt; n:\rreturn S\rreturn ans\r  ","description":"","id":14,"section":"posts","tags":["leetCodeEasy"],"title":"LeetCode 面试题 01.06","uri":"https://iiijesusiii.github.io/Teletubby/zh/posts/leetcode-interview-problems-0106/"},{"content":" 我的 python 版本 是 3.7\n f-string 已收录在 python daily tips  原文来自: sunxb10-Python格式化字符串f-string概览\n f-string 亦称为 格式化字符串常量 (formatted string literals)，是Python3.6新引入的一种字符串格式化方法，该方法源于 PEP 498 – Literal String Interpolation, 主要目的是使格式化字符串的操作更加简便。f-string 是一个以\u0026rsquo;f\u0026rsquo; 或 \u0026lsquo;F\u0026lsquo;为前缀的字符串 (就像 f\u0026rsquo;xxx\u0026rsquo; 或 F\u0026rsquo;xxx\u0026rsquo;)。需要替换的字段由大括号{}括起来。\nf-string在本质上并不是字符串常量，而是一个在运行时运算求值的表达式\nf-string在功能方面不逊于传统的 %-formatting 语句和 str.format() 函数，同时性能又优于二者，且使用起来也更加简洁明了，因此对于Python3.6及以后的版本，推荐使用f-string进行字符串格式化。\n常用方法 f-string用大括号 {} 表示被替换字段，其中直接填入替换内容：\n1 2 3 4 5 6 7 8 9 10 11  \u0026gt;\u0026gt;\u0026gt; name = \u0026#39;Eric\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;Hello, my name is {name}\u0026#39;\r\u0026#39;Hello, my name is Eric\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; number = 7\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;My lucky number is {number}\u0026#39;\r\u0026#39;My lucky number is 7\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; price = 19.99\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;The price of this book is {price}\u0026#39;\r\u0026#39;The price of this book is 19.99\u0026#39;\r  表达式求值与函数调用 f-string的大括号 {} 可以填入表达式或调用函数，Python会求出其结果并填入返回的字符串内：\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026gt;\u0026gt;\u0026gt; f\u0026#39;A total number of {24 * 8 + 4}\u0026#39;\r\u0026#39;A total number of 196\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;Complex number {(2 + 2j) / (2 - 3j)}\u0026#39;\r\u0026#39;Complex number (-0.15384615384615388+0.7692307692307692j)\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; name = \u0026#39;ERIC\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;My name is {name.lower()}\u0026#39;\r\u0026#39;My name is eric\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; import math\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;The answer is {math.log(math.pi)}\u0026#39;\r\u0026#39;The answer is 1.1447298858494002\u0026#39;\r  引号、反斜杠与大括号转义 引号  f-string大括号内所用的引号不能和大括号外的引号定界符冲突，可根据情况灵活切换 ' 和 \u0026quot;：  1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; f\u0026#39;I am {\u0026#34;Eric\u0026#34;}\u0026#39;\r\u0026#39;I am Eric\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;I am {\u0026#39;Eric\u0026#39;}\u0026#39;\rFile \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1\rf\u0026#39;I am {\u0026#39;Eric\u0026#39;}\u0026#39;\r^\rSyntaxError: invalid syntax\r   若 ' 和 \u0026quot; 不足以满足要求，还可以使用 ''' 和 \u0026quot;\u0026quot;\u0026quot;：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026gt;\u0026gt;\u0026gt; f\u0026#34;He said {\u0026#34;I\u0026#39;m Eric\u0026#34;}\u0026#34;\r File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1\rf\u0026#34;He said {\u0026#34;I\u0026#39;m Eric\u0026#34;}\u0026#34;\r ^\rSyntaxError: invalid syntax\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;He said {\u0026#34;I\u0026#39;m Eric\u0026#34;}\u0026#39;\r File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1\rf\u0026#39;He said {\u0026#34;I\u0026#39;m Eric\u0026#34;}\u0026#39;\r ^\rSyntaxError: invalid syntax\r\u0026gt;\u0026gt;\u0026gt; f\u0026#34;\u0026#34;\u0026#34;He said {\u0026#34;I\u0026#39;m Eric\u0026#34;}\u0026#34;\u0026#34;\u0026#34;\r\u0026#34;He said I\u0026#39;m Eric\u0026#34;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;\u0026#39;\u0026#39;He said {\u0026#34;I\u0026#39;m Eric\u0026#34;}\u0026#39;\u0026#39;\u0026#39;\r\u0026#34;He said I\u0026#39;m Eric\u0026#34;\r  反斜杠 大括号外的引号还可以使用 \\ 转义，但大括号内不能使用 \\ 转义：\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; f\u0026#39;\u0026#39;\u0026#39;He\\\u0026#39;ll say {\u0026#34;I\u0026#39;m Eric\u0026#34;}\u0026#39;\u0026#39;\u0026#39;\r\u0026#34;He\u0026#39;ll say I\u0026#39;m Eric\u0026#34;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;\u0026#39;\u0026#39;He\u0026#39;ll say {\u0026#34;I\\\u0026#39;m Eric\u0026#34;}\u0026#39;\u0026#39;\u0026#39;\rFile \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1\rSyntaxError: f-string expression part cannot include a backslash\r  大括号（花括号） f-string大括号外如果需要显示大括号，则应输入连续两个大括号 {{ 和 }}：\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; f\u0026#39;5 {\u0026#34;{stars}\u0026#34;}\u0026#39;\r\u0026#39;5 {stars}\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;{{5}} {\u0026#34;stars\u0026#34;}\u0026#39;\r\u0026#39;{5} stars\u0026#39;\r  注意 上面提到，f-string大括号内不能使用 \\ 转义。\n事实上不仅如此，f-string大括号内根本就不允许出现 \\。如果确实需要 \\，则应首先将包含 \\ 的内容用一个变量表示，再在f-string大括号内填入变量名：\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; f\u0026#34;newline: {ord(\u0026#39;\\n\u0026#39;)}\u0026#34;\rFile \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1\rSyntaxError: f-string expression part cannot include a backslash\r\u0026gt;\u0026gt;\u0026gt; newline = ord(\u0026#39;\\n\u0026#39;)\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;newline: {newline}\u0026#39;\r\u0026#39;newline: 10\u0026#39;\r  多行f-string f-string还可用于多行字符串：\n1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; name = \u0026#39;Eric\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; age = 27\r\u0026gt;\u0026gt;\u0026gt; f\u0026#34;Hello!\u0026#34; \\\r... f\u0026#34;I\u0026#39;m {name}.\u0026#34; \\\r... f\u0026#34;I\u0026#39;m {age}.\u0026#34;\r\u0026#34;Hello!I\u0026#39;m Eric.I\u0026#39;m 27.\u0026#34;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#34;\u0026#34;\u0026#34;Hello!\r... I\u0026#39;m {name}.\r... I\u0026#39;m {age}.\u0026#34;\u0026#34;\u0026#34;\r\u0026#34;Hello!\\nI\u0026#39;m Eric.\\nI\u0026#39;m 27.\u0026#34;\r  自定义格式：对齐、宽度、符号、补零、精度、进制等 f-string采用 {content:format} 设置字符串格式，其中 content 是替换并填入字符串的内容，可以是变量、表达式或函数等，format 是格式描述符。采用默认格式时不必指定 {:format}，如上面例子所示只写 {content} 即可。\n关于格式描述符的详细语法及含义可查阅Python官方文档，这里按使用时的先后顺序简要介绍常用格式描述符的含义与作用：\n对齐相关格式描述符    格式描述符 含义与作用     \u0026lt; 左对齐（字符串默认对齐方式）   \u0026gt; 右对齐（数值默认对齐方式）   ^ 居中    数字符号相关格式描述符    格式描述符 含义与作用     + 负数前加负号（-），正数前加正号（+）   - 负数前加负号（-），正数前不加任何符号（默认）   （空格） 负数前加负号（-），正数前加一个空格     注：仅适用于数值类型。\n 数字显示方式相关格式描述符    格式描述符 含义与作用     # 切换数字显示方式     注1：仅适用于数值类型。\n注2：# 对不同数值类型的作用效果不同，详见下表：\n    数值类型 不加#（默认） 加# 区别     二进制整数 \u0026lsquo;1111011\u0026rsquo; \u0026lsquo;0b1111011\u0026rsquo; 开头是否显示 0b   八进制整数 \u0026lsquo;173\u0026rsquo; \u0026lsquo;0o173\u0026rsquo; 开头是否显示 0o   十进制整数 \u0026lsquo;123\u0026rsquo; \u0026lsquo;123\u0026rsquo; 无区别   十六进制整数（小写字母） \u0026lsquo;7b\u0026rsquo; \u0026lsquo;0x7b\u0026rsquo; 开头是否显示 0x   十六进制整数（大写字母） \u0026lsquo;7B\u0026rsquo; \u0026lsquo;0X7B\u0026rsquo; 开头是否显示 0X    宽度与精度相关格式描述符    格式描述符 含义与作用     width 整数 width 指定宽度   0width 整数 width 指定宽度，开头的 0 指定高位用 0 补足宽度   width.precision 整数 width 指定宽度，整数 precision 指定显示精度     注1：0width 不可用于复数类型和非数值类型，width.precision 不可用于整数类型。\n注2：width.precision 用于不同格式类型的浮点数、复数时的含义也不同：用于 f、F、e、E 和 % 时 precision 指定的是小数点后的位数，用于 g 和 G 时 precision 指定的是有效数字位数（小数点前位数+小数点后位数）。\n注3：width.precision 除浮点数、复数外还可用于字符串，此时 precision 含义是只使用字符串中前 precision 位字符。\n  示例：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026gt;\u0026gt;\u0026gt; a = 123.456\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;a is {a:8.2f}\u0026#39;\r\u0026#39;a is 123.46\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;a is {a:08.2f}\u0026#39;\r\u0026#39;a is 00123.46\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;a is {a:8.2e}\u0026#39;\r\u0026#39;a is 1.23e+02\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;a is {a:8.2%}\u0026#39;\r\u0026#39;a is 12345.60%\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;a is {a:8.2g}\u0026#39;\r\u0026#39;a is 1.2e+02\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; s = \u0026#39;hello\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;s is {s:8s}\u0026#39;\r\u0026#39;s is hello \u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;s is {s:8.3s}\u0026#39;\r\u0026#39;s is hel \u0026#39;\r  千位分隔符相关格式描述符    格式描述符 含义与作用     , 使用,作为千位分隔符   _ 使用_作为千位分隔符     注1：若不指定 , 或 ，则f-string不使用任何千位分隔符，此为默认设置。\n注2：, 仅适用于浮点数、复数与十进制整数：对于浮点数和复数，, 只分隔小数点前的数位。\n注3： 适用于浮点数、复数与二、八、十、十六进制整数：对于浮点数和复数，_ 只分隔小数点前的数位；对于二、八、十六进制整数，固定从低位到高位每隔四位插入一个 _（十进制整数是每隔三位插入一个 _）。\n  示例：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026gt;\u0026gt;\u0026gt; a = 1234567890.098765\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;a is {a:f}\u0026#39;\r\u0026#39;a is 1234567890.098765\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;a is {a:,f}\u0026#39;\r\u0026#39;a is 1,234,567,890.098765\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;a is {a:_f}\u0026#39;\r\u0026#39;a is 1_234_567_890.098765\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; b = 1234567890\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;b is {b:_b}\u0026#39;\r\u0026#39;b is 100_1001_1001_0110_0000_0010_1101_0010\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;b is {b:_o}\u0026#39;\r\u0026#39;b is 111_4540_1322\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;b is {b:_d}\u0026#39;\r\u0026#39;b is 1_234_567_890\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;b is {b:_x}\u0026#39;\r\u0026#39;b is 4996_02d2\u0026#39;\r  格式类型相关格式描述符 基本格式类型\n   格式描述符 含义与作用 适用变量类型     s 普通字符串格式 字符串   b 二进制整数格式 整数   c 字符格式，按unicode编码将整数转换为对应字符 整数   d 十进制整数格式 整数   o 八进制整数格式 整数   x 十六进制整数格式（小写字母） 整数   X 十六进制整数格式（大写字母） 整数   e 科学计数格式，以 e 表示 ×10^ 浮点数、复数、整数（自动转换为浮点数）   E 与 e 等价，但以 E 表示 ×10^ 浮点数、复数、整数（自动转换为浮点数）   f 定点数格式，默认精度（precision）是6 浮点数、复数、整数（自动转换为浮点数）   F 与 f 等价，但将 nan 和 inf 换成 NAN 和 INF 浮点数、复数、整数（自动转换为浮点数）   g 通用格式，小数用 f，大数用 e 浮点数、复数、整数（自动转换为浮点数）   G 与 G 等价，但小数用 F，大数用 E 浮点数、复数、整数（自动转换为浮点数）   % 百分比格式，数字自动乘上100后按 f 格式排版，并加 % 后缀 浮点数、整数（自动转换为浮点数）    常用的特殊格式类型：标准库 datetime 给定的用于排版时间信息的格式类型，适用于 date、datetime 和 time 对象\n   格式描述符 含义 显示样例     %a 星期几（缩写） \u0026lsquo;Sun\u0026rsquo;   %A 星期几（全名） \u0026lsquo;Sunday\u0026rsquo;   %w 星期几（数字，0 是周日，6 是周六） \u0026lsquo;0\u0026rsquo;   %u 星期几（数字，1 是周一，7 是周日） \u0026lsquo;7\u0026rsquo;   %d 日（数字，以 0 补足两位） \u0026lsquo;07\u0026rsquo;   %b 月（缩写） \u0026lsquo;Aug\u0026rsquo;   %B 月（全名） \u0026lsquo;August\u0026rsquo;   %m 月（数字，以 0 补足两位） \u0026lsquo;08\u0026rsquo;   %y 年（后两位数字，以 0 补足两位） \u0026lsquo;14\u0026rsquo;   %Y 年（完整数字，不补零） \u0026lsquo;2014\u0026rsquo;   %H 小时（24小时制，以 0 补足两位） \u0026lsquo;23\u0026rsquo;   %I 小时（12小时制，以 0 补足两位） \u0026lsquo;11\u0026rsquo;   %p 上午/下午 \u0026lsquo;PM\u0026rsquo;   %M 分钟（以 0 补足两位） \u0026lsquo;23\u0026rsquo;   %S 秒钟（以 0 补足两位） \u0026lsquo;56\u0026rsquo;   %f 微秒（以 0 补足六位） \u0026lsquo;553777\u0026rsquo;   %z UTC偏移量（格式是 ±HHMM[SS]，未指定时区则返回空字符串） \u0026lsquo;+1030\u0026rsquo;   %Z 时区名（未指定时区则返回空字符串） \u0026lsquo;EST\u0026rsquo;   %j 一年中的第几天（以 0 补足三位） \u0026lsquo;195\u0026rsquo;   %U 一年中的第几周（以全年首个周日后的星期为第0周，以 0 补足两位） \u0026lsquo;27\u0026rsquo;   %w 一年中的第几周（以全年首个周一后的星期为第0周，以 0 补足两位） \u0026lsquo;28\u0026rsquo;   %V 一年中的第几周（以全年首个包含1月4日的星期为第1周，以 0 补足两位） \u0026lsquo;28\u0026rsquo;     综合示例  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  \u0026gt;\u0026gt;\u0026gt; a = 1234\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;a is {a:^#10X}\u0026#39; # 居中，宽度10位，十六进制整数（大写字母），显示0X前缀\r \u0026#39;a is 0X4D2 \u0026#39;\r\u0026gt;\u0026gt;\u0026gt; b = 1234.5678\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;b is {b:\u0026lt;+10.2f}\u0026#39; # 左对齐，宽度10位，显示正号（+），定点数格式，2位小数\r \u0026#39;b is +1234.57 \u0026#39;\r\u0026gt;\u0026gt;\u0026gt; c = 12345678\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;c is {c:015,d}\u0026#39; # 高位补零，宽度15位，十进制整数，使用,作为千分分割位\r \u0026#39;c is 000,012,345,678\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; d = 0.5 + 2.5j\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;d is {d:30.3e}\u0026#39; # 宽度30位，科学计数法，3位小数\r \u0026#39;d is 5.000e-01+2.500e+00j\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; import datetime\r\u0026gt;\u0026gt;\u0026gt; e = datetime.datetime.today()\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;the time is {e:%Y-%m-%d(%a) %H:%M:%S}\u0026#39; # datetime时间格式\r \u0026#39;the time is 2018-07-14 (Sat) 20:46:02\u0026#39;\r  lambda表达式 f-string大括号内也可填入lambda表达式，但lambda表达式的 : 会被f-string误认为是表达式与格式描述符之间的分隔符，为避免歧义，需要将lambda表达式置于括号 () 内：\n 示例：  1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; f\u0026#39;result is {lambda x: x ** 2 + 1 (2)}\u0026#39;\rFile \u0026#34;\u0026lt;fstring\u0026gt;\u0026#34;, line 1\r(lambda x)\r^\rSyntaxError: unexpected EOF while parsing\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;result is {(lambda x: x ** 2 + 1) (2)}\u0026#39;\r\u0026#39;result is 5\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;result is {(lambda x: x ** 2 + 1) (2):\u0026lt;+7.2f}\u0026#39;\r\u0026#39;result is +5.00 \u0026#39;\r  参考文档   Python格式化字符串f-string概览 Python Documentation – Formatted String Literals Python Documentation – Format String Syntax PEP 498 – Literal String Interpolation Python 3’s f-Strings: An Improved String Formatting Syntax (Guide) python3 f-string格式化字符串的高级用法 Python 3: An Intro to f-strings   ","description":"","id":15,"section":"posts","tags":["python"],"title":"Python f-string","uri":"https://iiijesusiii.github.io/Teletubby/zh/posts/python-f-string/"},{"content":"LeetCode 409. 最长回文串 已收录在 my LeetCode 题目 给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。\n在构造过程中，请注意区分大小写。比如 \u0026ldquo;Aa\u0026rdquo; 不能当做一个回文字符串。\n示例 1 2 3 4 5 6  输入:\u0026#34;abccccdd\u0026#34;\r输出:7\r解释:\r我们可以构造的最长的回文串是\u0026#34;dccaccd\u0026#34;, 它的长度是 7。\r  留意 假设字符串的长度不会超过 1010。\n题解 方法一 在回文串的最中间可以有奇数字母[2]。\n因此先使用 collections.Counter 创建一个字典（dict）哈希表，来记录各个字母的数量。\n遍历哈希表，如果该字母为偶数字母[1]，cnt += Counter[letter].value()，否则 cnt += Counter[letter].value() - 1(为了保证添加的字母都是偶数个，可以构成回文串)，然后 cnt += 1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution:\rdef longestPalindrome(self, s: str) -\u0026gt; int:\rht = collections.Counter(s)\rflag = cnt = 0\rfor i in ht:\rval = ht[i]\rif val \u0026amp; 1 == 0:\rcnt += val\relse:\rcnt += val - 1\rflag = 1\rif flag:\rcnt += 1\rreturn cnt\r  Ⅱ 另一种方法，我们可以反过来计算。\n用输入字符串的长度 len(s) 减去 oddCnt (*奇数字母[2]*的个数)，然后再加上 1 (如果 oddCnt \u0026gt; 0)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution:\rdef longestPalindrome(self, s: str) -\u0026gt; int:\r#2\r ht = collections.Counter(s)\rflag = oddCnt = 0\rfor i in ht:\rif ht[i] \u0026amp; 1 == 1:\roddCnt += 1\rflag = 1\rreturn len(s) - oddCnt + flag\r#1\r \u0026#39;\u0026#39;\u0026#39;\rht = collections.Counter(s)\rreturn len(s) - max(0,sum(ht[i]%2 for i in ht)-1)\r\u0026#39;\u0026#39;\u0026#39;\r  注解 [1]偶数字母：表示出现次数为偶数的字母。\n[2]奇数字母：表示出现次数为奇数的字母。\n注：仅限本文，后叙亦同\n","description":"","id":16,"section":"posts","tags":["哈希表","leetCodeEasy"],"title":"LeetCode 409","uri":"https://iiijesusiii.github.io/Teletubby/zh/posts/leetcode-409/"},{"content":" 我的 python 版本 是 3.7\n Python 中 collections.Counter() 的时间复杂度 正由 源码 所示, Counter 就是 字典 的子类. 构造它是 O(n), 因为对需要输入进行遍历，但是它对每个单元的操作仍是 O(1)。\n注意，从源码中还可以知道它在内部并没有保持一种有序的状态，而是通过最常见的输出方法（***__repr__***）进行简单的降序排序，并输出。\n 译自: StackOverflow-What is the time complexity of collections.Counter() in Python?\n ","description":"","id":17,"section":"posts","tags":["python"],"title":"Python collections.Counter 的时间复杂度","uri":"https://iiijesusiii.github.io/Teletubby/zh/posts/python-counter-time-complexity/"},{"content":" 我的 python 版本 是 3.7\n Python内置方法的时间复杂度 已收录在 python daily tips  译自 Python Wiki\n 本页面涵盖了Python中若干方法的 时间复杂度（或者叫\u0026quot;O\u0026rdquo;(大欧)）。该时间复杂度的计算基于当前 (最近一次由 JonathanHartley 编辑于 2017-06-05 19:58:18) 的CPython实现。其他Python的实现（包括老版本或者尚在开发的CPython实现）可能会在性能表现上有些许小小的差异，但一般不超过一个O(log n)。\n本文中，’n’代表容器中元素的数量，’k’代表参数的值，或者参数的数量。\n列表（list） 以随机数为参数生成的列表来表示平均情况\n列表是以 数组（Array） 实现的。最大的开销发生在超过当前分配大小的增长，这种情况下所有元素都需要移动；或者是在起始位置附近插入或者删除元素，这种情况下所有在该位置后面的元素都需要移动。如果你需要在一个队列的两端进行增删的操作，应当使用 collections.deque（双向队列）\n   操作 平均情况 最坏情况（平摊）     Copy O(n) O(n)   Append[1] O(1) O(1)   Pop last O(1) O(1)   Pop intermediate O(k) O(k)   Insert O(n) O(n)   Get Item O(1) O(1)   Set Item O(1) O(1)   Delete Item O(n) O(n)   Iteration O(n) O(n)   Get Slice O(k) O(k)   Del Slice O(n) O(n)   Set Slice O(k+n) O(k+n)   Extend[1] O(k) O(k)   Sort O(n log n) O(n log n)   Multiply O(nk) O(nk)   x in s O(n)    min(s), max(s) O(n)    Get Length O(1) O(1)    双向队列（collections.deque） deque （double-ended queue，双向队列）是以双向链表的形式实现的 (Well, a list of arrays rather than objects, for greater efficiency)。双向队列的两端都是可达的，但从查找队列中间的元素较为缓慢，增删元素就更慢了。\n   操作 平均情况 最坏情况（平摊）     Copy O(n) O(n)   append O(1) O(1)   appendleft O(1) O(1)   pop O(1) O(1)   popleft O(1) O(1)   extend O(k) O(k)   extendleft O(k) O(k)   rotate O(k) O(k)   remove O(n) O(n)    集合（set） 未列出的操作可参考 dict —— 二者的实现非常相似。\n   操作 平均情况 最坏情况 备注     x in s O(1) O(n)    Union s | t O(len(s)+len(t))     Intersection s\u0026amp;t O(min(len(s), len(t)) O(len(s) * len(t)) replace \u0026ldquo;min\u0026rdquo; with \u0026ldquo;max\u0026rdquo; if t is not a set   Multiple intersection s1\u0026amp;s2\u0026amp;..\u0026amp;sn  (n-1)*O(l) where l is max(len(s1),..,len(sn))    Difference s - t O(len(s))     s.difference_update(t) O(len(t))     Symmetric Difference s^t O(len(s)) O(len(s) * len(t))    s.symmetric_difference_update(t) O(len(t)) O(len(t) * len(s))      由源码得知，求差集（ s-t，或 s.difference(t) ）运算与更新为差集（ s.difference_uptate(t) ）运算的时间复杂度并不相同！前者是将在s中，但不在t中的元素添加到新的集合中，因此时间复杂度为O( len(s) )；后者是将在t中的元素从s中移除，因此时间复杂度为O( len(t) )。因此，使用时请留心，根据两个集合的大小以及是否需要新集合来选择合适的方法。\n集合的 s-t 运算中，并不要求t也一定是集合。只要 t 是可遍历的对象即可。\n 字典（dict） 表示平均情况：\n 对象的散列函数（哈希函数）足够撸棒（robust）或者说足够健壮，不会发生冲突。 字典的键是从所有可能的键的集合中随机选择的。\n注意 只使用字符串作为字典的键。这么做虽然不会影响算法的时间复杂度，但会对常数项产生显著的影响，这决定了你的一段程序能多快跑完。     操作 平均情况 最坏情况（平摊）     Copy[2] O(n) O(n)   Get Item O(1) O(n)   Set Item[1](更改元素) O(1) O(n)   Delete Item O(1) O(n)   Iteration[2] O(n) O(n)    注意 可能翻译有些词不达意😂\n[1] = 这些操作的时间复杂度取决于\u0026rdquo;最坏情况\u0026ldquo;的\u0026rdquo;平摊\u0026ldquo;部分。根据容器的历史记录，单个操作可能会花费很长的时间\n[2] = 对于这些操作，最坏的情况 n 是容器曾达到的最大值而不仅是当前值。例如先将N个对象添加到字典中，然后再删除N-1个，改字典仍需（至少）调整至N个对象的大小，直到下一次的插入操作完成。\n原文 [1] = These operations rely on the \u0026ldquo;Amortized\u0026rdquo; part of \u0026ldquo;Amortized Worst Case\u0026quot;. Individual actions may take surprisingly long, depending on the history of the container.\n[2] = For these operations, the worst case n is the maximum size the container ever achieved, rather than just the current size. For example, if N objects are added to a dictionary, then N-1 are deleted, the dictionary will still be sized for N objects (at least) until another insertion is made.\n","description":"","id":18,"section":"posts","tags":["python"],"title":"Python之时间复杂度","uri":"https://iiijesusiii.github.io/Teletubby/zh/posts/python-time-complexity/"},{"content":" 我的 python 版本 是 3.7\n Python3.7 中获取代码的几种方法  timeit \u0026ndash; 测量小代码片段的执行时间\n 方法一 1 2 3 4 5  import timeit\rstart=timeit.default_timer()\r#中间写代码块\r end=timeit.default_timer()\rprint(\u0026#39;Running time: %sSeconds\u0026#39;%(end-start))\r  此外 1 2  %timeit (1, 2, 3)\r# 7.87 ns ± 0.261 ns per loop (mean ± std. dev. of 7 runs, 100000000 loops each)\r   方法二 1 2 3 4 5  import time\rstart =time.time()\r#中间写上代码块\r end = time.time()\rprint(\u0026#39;Running time: %sSeconds\u0026#39;%(end-start))\r  方法三 1 2 3 4 5  import time\rstart =time.perf_counter()\r#中间写上代码块\r end = time.perf_counter()\rprint(\u0026#39;Running time: %sSeconds\u0026#39;%(end-start))\r  方法四 1 2 3 4 5 6  import time\rstart =time.process_time()\r#中间写上代码块\r end = time.process_time()\rprint(\u0026#39;Running time: %sSeconds\u0026#39;%(end-start))\r#默认精确到小数点后一位\r   ","description":"","id":19,"section":"posts","tags":["python"],"title":"Python 计算代码的运行时间","uri":"https://iiijesusiii.github.io/Teletubby/zh/posts/python-code-runtime/"},{"content":" 我的 python 版本 是 3.7\n Python for-else \u0026amp; while-else 语句 已收录在 python daily tips for-else 基本结构 这是for-else循环的基本结构：\n1 2 3 4 5 6 7 8  for item in container: if search_something(item): # 找到了! process(item) break else: # 没有找到任何东西。（for 循环正常遍历完） not_found_in_container()   说明 for-else 语句可能还有很多人不太熟悉，我也是在刷 LeetCode 的时候才看到的。其实容易理解，当你熟悉后这对你做题会有很大的帮助。\n 比如, LeetCode 1160. 拼写单词\n 常见的 for-else 的结构是在一个循环中寻找某个值。如果这个值找到了的话就会执行 break 跳出 for 循环，同时连着 else 一起跳出；或是到 for 循环结束时都没有找到需要的值，那么就会执行 else 语句。\nwhile-else 同样也有 while-else 语句，与 for-else 同理。\n 参考 https://book.pythontips.com/en/latest/for_-_else.html\n ","description":"","id":20,"section":"posts","tags":["python"],"title":"Python for-else 语句","uri":"https://iiijesusiii.github.io/Teletubby/zh/posts/python-for-else/"},{"content":"LeetCode 1160. 拼写单词 已收录在 my LeetCode 题目 给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。\n假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。\n注意：每次拼写（指拼写词汇表中的一个单词）时，chars 中的每个字母都只能用一次。\n返回词汇表 words 中你掌握的所有单词的 长度之和。\n示例 1 2 3 4 5 6 7 8 9  输入: words = [\u0026#34;cat\u0026#34;,\u0026#34;bt\u0026#34;,\u0026#34;hat\u0026#34;,\u0026#34;tree\u0026#34;], chars = \u0026#34;atach\u0026#34;\r输出: 6\r解释: 可以形成字符串 \u0026#34;cat\u0026#34; 和 \u0026#34;hat\u0026#34;，所以答案是 3 + 3 = 6。\r输入: words = [\u0026#34;hello\u0026#34;,\u0026#34;world\u0026#34;,\u0026#34;leetcode\u0026#34;], chars = \u0026#34;welldonehoneyr\u0026#34;\r输出: 10\r解释: 可以形成字符串 \u0026#34;hello\u0026#34; 和 \u0026#34;world\u0026#34;，所以答案是 5 + 5 = 10。\r  留意  1 \u0026lt;= words.length \u0026lt;= 1000 1 \u0026lt;= words[i].length, chars.length \u0026lt;= 100 所有字符串中都仅包含小写英文字母  题解 方法一 用 collections.Counter 来创建一个 哈希表 去比较 word 中与 chars 中的字母个数.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution:\rdef countCharacters(self, words: List[str], chars: str) -\u0026gt; int:\r#1\r cnt = ans = 0\rtmp = hm = collections.Counter(chars)\rfor word in words:\rcnt = 0\rtmp = copy.copy(hm)\rfor ch in word:\rif ch in tmp and tmp[ch] \u0026gt; 0:\rcnt += 1\rtmp[ch] -= 1\relse:\rcnt = 0\rbreak\rans += cnt\rreturn ans\r  方法二 for-else 使用 for-else 语句，更加简洁。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Solution:\rdef countCharacters(self, words: List[str], chars: str) -\u0026gt; int:\r#2.1\r #一个哈希表，比v2.0（后面那段代码）要快\r ans = 0\rht = collections.Counter(chars)\rfor word in words:\rfor ch in word:\rif ch not in ht or word.count(ch) \u0026gt; hm[ch]:\rbreak\relse:\rans += len(word)\rreturn ans\r#2.0\r #两个哈希表\r \u0026#39;\u0026#39;\u0026#39;\rchars_cnt = collections.Counter(chars)\rans = 0\rfor word in words:\rword_cnt = collections.Counter(word)\rfor c in word_cnt:\rif chars_cnt[c] \u0026lt; word_cnt[c]:\rbreak\relse:\rans += len(word)\rreturn ans\u0026#39;\r\u0026#39;\u0026#39;\u0026#39;\r  ","description":"","id":21,"section":"posts","tags":["哈希表","leetCodeEasy"],"title":"LeetCode 1160","uri":"https://iiijesusiii.github.io/Teletubby/zh/posts/leetcode-1160/"},{"content":"使用 Github 托管个人静态网站 已收录在 Hugo Blog 这个托管你个人博客的方法既简便又快捷。\n更改你的发布（publish）目录 删除 \u0026ldquo;public\u0026rdquo; 文件夹 如果你博客的 根目录 下有 \u0026ldquo;public\u0026rdquo; 文件夹的话，就把它先删掉。\nsudo rm -rf dd\n将 发布目录 改为 docs $ hugo --destination docs --gc server\n这条这令会在你博客的根目录下创建一个 \u0026ldquo;docs\u0026rdquo; 文件夹, 并且在本地启动 Hugo 服务器。\n\u0026ndash;gc 选项, 在构建后删除未使用的缓存文件。\n检查你的静态网站 启动 hugo 服务器后，可以通过命令行的提示去打开运行在本地的静态网站。\n如果没有什么错误的话, 继续下一步。\n创建一个公共仓库 注册 Github (如果已经有Github账号的话可以跳过这步) 注册 Github\n新建公共仓库 给仓库取个🐂🍺的名字, 之后你个人网站会像这样 https://用户名.github.io/仓库名/\n 如果你不知道怎么新建仓库, 点这\n 将你的 \u0026ldquo;docs\u0026rdquo; 文件夹 push 到仓库 创建一个 .gitignore 文件 在你的根文件夹 中创建 .gitignore 文件将更加方便执行 git push.\n 如果你不会创建，这个会对你有帮助\n git push 指令  如果不太清楚，点这里\n 🎉现在你的静态网站已经被托管到 Github 啦 相关  Git Commands \u0026amp; FAQ\nhugo host on Github\nGitHub Pages\n ","description":"","id":22,"section":"posts","tags":["hugo","github"],"title":"将Hugo托管在Github上","uri":"https://iiijesusiii.github.io/Teletubby/zh/posts/hugo-host-on-github/"},{"content":"已收录在 Hugo Blog (你想给你自己整一个静态网站吗?) 已收录在 Git Commands \u0026amp; FAQ git clone 这里有两种方法去使用 git clone\n1. 使用 HTTPS 这是一个克隆自己或者别人在 Github 上的仓库的一个简单的方法\ngit clone HTTPS(https://github.com/example.git)\n2. 使用 SSH 这个方法只能克隆自己已配置好的仓库，或者克隆别人已给你私钥的仓库\ngit clone SSH(git@github.com:example.git)\n给自己的仓库配置 SSH KEY $ ssh-keygen\r#生成 *rsa* 钥匙对\r#第一行选择 rsa 密钥的存储位置，回车即默认地址\r#对于 *Win10用户* 默认位置是/c/User/你的系统用户名/.ssh/id_rsa\r#后面两行输入两次密码，可以直接按两次回车\r$ cd ~/.ssh\r$ cat ~/.ssh/id_rsa.pub\r#查看你公钥的内容\r#将你的公钥复制粘贴到 *github* 或其他代码托管网站\r$ ssh -T git@github.com\r#检查与 Github 的连接\rgit push $ git init\r$ touch .gitignore\r$ vim .gitignore #输入需要被 *git add* 忽略的文件名或文件夹名\r$ git add . #或者 git add \u0026lt;文件名 or 文件夹名\u0026gt;\r$ git commit -m \u0026quot;第一次提交\u0026quot; #-m 选项, 添加此次 commit 的描述\r$ git remote add origin HTTPSorSSH\r#格式: git remote add \u0026lt;远程仓库名\u0026gt; \u0026lt;远程仓库的HTTPS或者SSH\u0026gt;\r$ git push -u origin master #远程仓库名为 origin\r#当前分支为 master\r#-u 选项, 设置默认的远程仓库名\r#下次push时，只需要输入\u0026quot;git push\u0026quot;\r可以输入\u0026quot;git push -h\u0026quot;获取更多帮助\n清空你 GitHub 上某个仓库的内容 $ git rm -rf *\r$ gir commit -m \u0026quot;清空仓库\u0026quot;\r$ git push -f\r","description":"","id":23,"section":"posts","tags":["git","github"],"title":"Git 基本指令 1","uri":"https://iiijesusiii.github.io/Teletubby/zh/posts/git-basic-commands-1/"},{"content":"已收录在 Hugo Blog (你想给你自己整一个静态网站吗?) 什么是 Git? Git是一个免费的开源的分布式版本控制系统工具，能够快速高效地处理从小型到大型项目的所有内容。\n 参考 https://git-scm.com/\n 下载 Git Windows\rLinux\rMacOS\r\rchoco install git.install\r#or\rscoop install git\r 如果你没有下载任何 包管理器 或者 下载器, 比如 choco, scoop 这些\n没关系, 点这下载Git\n\r下列以\u0026rdquo;#\u0026ldquo;开头的指令需要root权限. Ubuntu sudo apt-get install git\nFedora # dnf install git Fedora 22 and later\n# yum install git up to Fedora 21\nGentoo # emerge --ask --verbose dev-vcs/git\nArch Linux # pacman -S git\nopenSUSE # zypper install git\nMageia # urpmi git\nNix/NixOS # nix-env -i git\nFreeBSD # pkg install git\nSolaris 9/10/11 (OpenCSW) # pkgutil -i git\nSolaris 11 Express # pkg install developer/versioning/git\nOpenBSD # pkg_add git\nAlpine $ apk add git\nSlitaz $ tazpkg get-install git\n\rXcode 已经集成了 Git\n安装\u0026quot;Command Line Tools\u0026rdquo;(命令行工具)\r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"d6e338352578a5c7\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar tabLinks = null;\rvar tabContents = null;\rvar ids = [];\rif (containerElem) {\rtabLinks = containerElem.querySelectorAll('.tab__link');\rtabContents = containerElem.querySelectorAll('.tab__content');\r}\rfor (var i = 0; i 0) {\rtabContents[0].style.display = 'block';\r}\r 安装 \u0026amp; 配置 Git 如果你现在是 Win10 用户，并且下载的是个 .exe, 可执行文件 的话, 直接双击打开执行，一直点击 \u0026ldquo;next\u0026rdquo; 到安装完毕。\n检查是否安装成功，输入下面指令:\ngit version\n由于 Git 是一个分布式版本控制系统, 所以机器每次执行指令时都需要上报家门。像如下，给你的机器配置 userName 和 emailAddr :\n$ git config --global user.name \u0026quot;你的用户名\u0026quot;\r$ git config --global user.email \u0026quot;你的邮箱地址\u0026quot;\r 注意❗ 这个 git config 的 \u0026ndash;global 参数。使用这个 全局参数 的话，意味着在你机器上的所有 仓库 都会使用相同的配置，当然你也可以为你这些 仓库 配置其他不同的 用户名 和 电子邮箱。\n 查看帮助 Git 的基本指令:\nusage: git [--version] [--help] [-C \u0026lt;path\u0026gt;] [-c name=value]\r[--exec-path[=\u0026lt;path\u0026gt;]] [--html-path] [--man-path] [--info-path]\r[-p | --paginate | --no-pager] [--no-replace-objects] [--bare]\r[--git-dir=\u0026lt;path\u0026gt;] [--work-tree=\u0026lt;path\u0026gt;] [--namespace=\u0026lt;name\u0026gt;]\r\u0026lt;command\u0026gt; [\u0026lt;args\u0026gt;]\rThese are common Git commands used in various situations:\rstart a working area (see also: git help tutorial)\rclone Clone a repository into a new directory\rinit Create an empty Git repository or reinitialize an existing one\rwork on the current change (see also: git help everyday)\radd Add file contents to the index\rmv Move or rename a file, a directory, or a symlink\rreset Reset current HEAD to the specified state\rrm Remove files from the working tree and from the index\rexamine the history and state (see also: git help revisions)\rbisect Use binary search to find the commit that introduced a bug\rgrep Print lines matching a pattern\rlog Show commit logs\rshow Show various types of objects\rstatus Show the working tree status\rgrow, mark and tweak your common history\rbranch List, create, or delete branches\rcheckout Switch branches or restore working tree files\rcommit Record changes to the repository\rdiff Show changes between commits, commit and working tree, etc\rmerge Join two or more development histories together\rrebase Reapply commits on top of another base tip\rtag Create, list, delete or verify a tag object signed with GPG\rcollaborate (see also: git help workflows)\rfetch Download objects and refs from another repository\rpull Fetch from and integrate with another repository or a local branch\rpush Update remote refs along with associated objects\r'git help -a' and 'git help -g' list available subcommands and some\rconcept guides. See 'git help \u0026lt;command\u0026gt;' or 'git help \u0026lt;concept\u0026gt;'\rto read about a specific subcommand or concept.\r还是那句老话, 其实你所需要的就是在命令行中输入\u0026quot;git \u0026ndash;help\u0026rdquo;，然后查阅就行了。\n这里是 我的Git Commands \u0026amp; FAQ\n这里是 Git 官方指南\n已收录在 Hugo Blog ","description":"","id":24,"section":"posts","tags":["git","github"],"title":"安装 Git","uri":"https://iiijesusiii.github.io/Teletubby/zh/posts/install-git/"},{"content":"来白手建站吧，搭建一个hugo静态网站 已收录在 Hugo Blog 为什么选择 Hugo? \u0026amp; 什么是 Hugo? Hugo是一种用Go语言编写的快速的、现代静态网站生成器，为能够更有趣的创建网站而设计。 \u0026hellip;由于浏览网站的频率远远高于编辑网站，因此Hugo旨在为您的网站的终端用户提供最佳的浏览体验，并为网站作者提供理想的写作体验。\n 参考 https://gohugo.io/about/what-is-hugo/\n 简单的说: 快！很快！还简洁!清爽，爽歪歪的爽！\n开始吧! 安装 Hugo  参考官方文档 https://gohugo.io/getting-started/quick-start/\n Windows\rMacOS\rUbuntu\r\rchoco install hugo -confirm #or scoop install hugo \r brew install hugo \r sudo apt install hugo \r \r\r'use strict';\rvar containerId = JSON.parse(\"\\\"a41cd40346e4d5c0\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar tabLinks = null;\rvar tabContents = null;\rvar ids = [];\rif (containerElem) {\rtabLinks = containerElem.querySelectorAll('.tab__link');\rtabContents = containerElem.querySelectorAll('.tab__content');\r}\rfor (var i = 0; i 0) {\rtabContents[0].style.display = 'block';\r}\r 博主现在用的是 Win10系统,如果你不知道什么是 choco 或者 scoop 没事,直接下载已经编译好的可执行文件 .exe，下载好后直接将 .exe文件拖到命令行中，按回车执行即可，点此下载\n查看安装的Hugo版本:\nhugo version\n我的 Hugo 版本显示 Hugo Static Site Generator v0.66.0/extended windows/amd64 BuildDate: unknown ,emem\u0026hellip;简短就是 extended v0.66.0\n创建静态网站 如果你已经 安装 Git ,就直接在你想要创建网站的文件夹处右击 Git bash here。\n或者你也可以执行 cd 指令到那个文件夹, 然后输入如下指令：\n#format: hugo new site [path] [flags] hugo new site urSiteName 添加主题 首先安装 Git，然后从GitHub下载主题到你创建站点的子目录themes中：\n官方 Hugo 主题\n此博客的主题是 zzo, 你可以在主题作者的Github上 PR 并且给你的主题使用 git submodule 操作。\n如果你不清楚 Git 或者 GitHub 的基操, 请先 看看这 或者查阅 官方文档\ncd urSiteName #到你刚刚创建的文件夹中 git init git submodule add https://balabala.....git themes/themeName 试一手 ❗ 运行示例网站（demo） 从你的根目录（你创建站点的文件夹）中依次 themes/zzo/exampleSite 找到 exampleSite, 并在此目录下执行如下指令：\nhugo server --themesDir ../..\n配置主题并使用 你可以在那些主题页面上看到主题的说明文档，能够知道如何使用。这个 zzo主题 有自己专门的说明文档\n这些文档详细的说明了如何使用其主题，如何客制化主题等详细内容，值得一看。\n添加些内容 在你网站文件夹的根目录输入以下指令\nhugo new posts/hello-hugo.md\n.md 是一种 Markdown 文件, 应该使用 Markdown 语法去编辑, 如果你不知道，这是一本很好上手的 指南\n如果你知道怎么使用的话，那就开始动笔写点东西吧 ;-)\n--- title: \u0026quot;Hello Hugo\u0026quot; date: 2020-03-08T17:35:41+08:00 draft: true ---  ❗这个 .md 文件的 draft 属性 的初始状态是 true.\n 开启 hugo server 1.如果你没有将那文件的 draft 属性 改为 false, 那你也可以在启用 draft 的情况下启动 Hugo server :\nhugo server -D\n如果你的 端口：1313 处于可用状态，它会帮你布置到 http://localhost:1313/ ，否则会自动帮你找一个可用的端口并且搭建好。\n2.如果你已经将要发布的文章更改晚上且将 draft 属性 改为 false 的话。那就简单了，直接敲上：\nhugo server\n然后 按下回车 ，就好了。\n查看帮助 Hugo 的基本指令:\nhugo is the main command, used to build your Hugo site. Hugo is a Fast and Flexible Static Site Generator built with love by spf13 and friends in Go. Complete documentation is available at http://gohugo.io/. Usage: hugo [flags] hugo [command] Available Commands: config Print the site configuration convert Convert your content to different formats deploy Deploy your site to a Cloud provider. env Print Hugo version and environment info gen A collection of several useful generators. help Help about any command import Import your site from others. list Listing out various types of content mod Various Hugo Modules helpers. new Create new content for your site server A high performance webserver version Print the version number of Hugo Flags: -b, --baseURL string hostname (and path) to the root, e.g. http://spf13.com/ -D, --buildDrafts include content marked as draft -E, --buildExpired include expired content -F, --buildFuture include content with publishdate in the future --cacheDir string filesystem path to cache directory. Defaults: $TMPDIR/hugo_cache/ --cleanDestinationDir remove files from destination not found in static directories --config string config file (default is path/config.yaml|json|toml) --configDir string config dir (default \u0026quot;config\u0026quot;) -c, --contentDir string filesystem path to content directory --debug debug output -d, --destination string filesystem path to write files to --disableKinds strings disable different kind of pages (home, RSS etc.) --enableGitInfo add Git revision, date and author info to the pages -e, --environment string build environment --forceSyncStatic copy all files when static is changed. --gc enable to run some cleanup tasks (remove unused cache files) after the build -h, --help help for hugo --i18n-warnings print missing translations --ignoreCache ignores the cache directory --ignoreVendor ignores any _vendor directory -l, --layoutDir string filesystem path to layout directory --log enable Logging --logFile string log File path (if set, logging enabled automatically) --minify minify any supported output format (HTML, XML etc.) --noChmod don't sync permission mode of files --noTimes don't sync modification time of files --path-warnings print warnings on duplicate target paths etc. --quiet build in quiet mode --renderToMemory render to memory (only useful for benchmark testing) -s, --source string filesystem path to read files relative from --templateMetrics display metrics about template executions --templateMetricsHints calculate some improvement hints when combined with --templateMetrics -t, --theme strings themes to use (located in /themes/THEMENAME/) --themesDir string filesystem path to themes directory --trace file write trace to file (not useful in general) -v, --verbose verbose output --verboseLog verbose logging -w, --watch watch filesystem for changes and recreate as needed Additional help topics: hugo check Contains some verification checks Use \u0026quot;hugo [command] --help\u0026quot; for more information about a command. 事实上，你只需要在命令行中键入\u0026quot;hugo \u0026ndash;help\u0026rdquo;，然后查阅就行了。\n在下一篇，将 使用Github托管静态网站\n关于搭建 Hugo Blog 的所有 Blog 都收录在 Hugo Blog\n","description":"","id":25,"section":"posts","tags":["hugo"],"title":"你好 Hugo","uri":"https://iiijesusiii.github.io/Teletubby/zh/posts/hello-hugo/"},{"content":"已收录在 Git Commands \u0026amp; FAQ 解决 git pull/push 每次都需要输入密码问题（使用GitHub私有库） git bash到你需要操作的文件夹\ngit config --global credential.helper store\n然后再执行一次 git pull or git push，会提示输入账号和密码，之后就不需要了\n 在本地生成一个文本文件，记录着你刚刚输入的用户名和密码\n 博主现在用的是win10系统，文件在 C:\\Users\\你的系统用户名，叫 .git-credentials 里面内容如下:\nhttps://userName:userPasswd@github.com\n解决 GitHub error fatal: HttpRequestException encountered 执行后（承上所述），如果出现如下错误：\nerror fatal: HttpRequestException encountered\n可能是你的 Git Windows credential Manager 版本较低，需要下载新版本\n如果还是出现同样的错误，可能你需要更新 Git 版本，获取Git最新版本\n 参考 codeshare: How to solve the GitHub error fatal: HttpRequestException encountered\n ","description":"","id":26,"section":"posts","tags":["git","github"],"title":"解决 git pull/push 每次都需要输入密码问题（使用GitHub私有库）","uri":"https://iiijesusiii.github.io/Teletubby/zh/posts/store-github-username-and-passwd/"},{"content":"天线宝宝的博客  这个博客取名源于我和我女朋友，嘻嘻嘻😄\n 主题是 zzo❗\nPowered by Hugo\n","description":"关于","id":27,"section":"","tags":null,"title":"关 于","uri":"https://iiijesusiii.github.io/Teletubby/zh/about/"}]