[{"content":"春思  李白\n 燕草如碧丝[1]，秦桑低绿枝[2]。\n当君怀归日， 是妾断肠时。\n春风不相识， 何事入罗帏[3]？\n作者简介 李白（701年－762年） ，字太白，号青莲居士，又号\u0026quot;谪仙人\u0026rdquo;，唐代伟大的浪漫主义诗人，被后人誉为\u0026quot;诗仙\u0026rdquo;，与杜甫并称为\u0026quot;李杜\u0026rdquo;，为了与另两位诗人李商隐与杜牧即\u0026quot;小李杜\u0026quot;区别，杜甫与李白又合称\u0026quot;大李杜\u0026rdquo;。\n赏析 《春思》是唐代伟大诗人李白所创作的新题乐府诗，闺怨诗。此诗写一位出征军人的妻子在明媚的春日里对丈夫梦绕魂牵的思念，以及对战争早日胜利的盼望，表现思妇的思边之苦及其对爱情的坚贞。全诗言辞朴实无华，情景交融，神骨气味高雅浑然，富有民歌特色。\n无理而妙是古典诗歌中一个常见的艺术特征。从李白的这首诗中不难看出，所谓无理而妙，就是指在看似违背常理、常情的描写中，反而更深刻地表现了各种复杂的感情。……\n注释  [1]燕草：指燕地的草。燕，河北省北部一带，此泛指北部边地，征夫所在之处。 [2]秦桑：秦地的桑树。秦，指陕西省一带，此指思妇所在之地。燕地寒冷，草木迟生于较暖的秦地。 [3]罗帏：丝织的帘帐。  参考  维基百科-李白\n百度百科-李白\n百度百科-春思\n百度百科-闺怨诗\n ","description":"","id":0,"section":"posts","tags":["李白","五言古诗"],"title":"#5 《春思》","uri":"https://Teletubby.github.io/zh/posts/poems-day-5/"},{"content":"LeetCode 820. 单词的压缩编码 已收录在 my LeetCode 题目 给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。\n例如，如果这个列表是 [\u0026ldquo;time\u0026rdquo;, \u0026ldquo;me\u0026rdquo;, \u0026ldquo;bell\u0026rdquo;]，我们就可以将其表示为 S = \u0026ldquo;time#bell#\u0026quot; 和 indexes = [0, 2, 5]。\n对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 \u0026quot;#\u0026quot; 结束，来恢复我们之前的单词列表。\n那么成功对给定单词列表进行编码的最小字符串长度是多少呢？\n示例 输入: words = [\u0026quot;time\u0026quot;, \u0026quot;me\u0026quot;, \u0026quot;bell\u0026quot;]\r输出: 10\r说明: S = \u0026quot;time#bell#\u0026quot; ， indexes = [0, 2, 5] 。\r留意  1 \u0026lt;= words.length \u0026lt;= 2000. 1 \u0026lt;= words[i].length \u0026lt;= 7. 每个单词都是小写字母 。  题解 方法一 代码实现 1 2 3 4 5 6 7 8 9 10 11  class Solution:\rdef minimumLengthEncoding(self, words: List[str]) -\u0026gt; int:\rwords.sort(key = lambda word : word[::-1])\rn = len(words)\rans = 0\rfor i in range(n):\rif i+1 \u0026lt; n and words[i+1].endswith(words[i]):\rpass\relse:\rans += len(words[i]) + 1\rreturn ans\r  方法二 代码实现 1 2 3 4 5 6 7 8 9 10  class Solution:\rdef minimumLengthEncoding(self, words: List[str]) -\u0026gt; int:\rwords = sorted(w[::-1] for w in words)\rres = [len(words[0])]\rfor i in range(1,len(words)):\rif words[i].startswith(words[i-1]):\rres[-1] = len(words[i])\relse:\rres.append(len(words[i]))\rreturn sum(res) + len(res)\r  ","description":"","id":1,"section":"posts","tags":["字典树","leetCodeMed"],"title":"LeetCode 820","uri":"https://Teletubby.github.io/zh/posts/leetcode-820/"},{"content":"LeetCode 面试题 28. 对称的二叉树 已收录在 my LeetCode 题目 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。\n例如，二叉树 [1,2,2,3,4,4,3] 是对称的。\n 1\r/ \\\r2 2\r/ \\ / \\\r3 4 4 3\r但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:\n 1\r/ \\\r2 2\r\\ \\\r3 3\r示例 输入：root = [1,2,2,3,4,4,3]\r输出：true\r输入：root = [1,2,2,null,3,null,3]\r输出：false\r题解 递归\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  # Definition for a binary tree node.\r # class TreeNode:\r # def __init__(self, x):\r # self.val = x\r # self.left = None\r # self.right = None\r class Solution:\rdef isSymmetric(self, root: TreeNode) -\u0026gt; bool:\rif not root:\rreturn True\rdef isSyt(left_,right_):\rif not left_ and not right_:\rreturn True\relif left_ and right_:\rif left_.val != right_.val:\rreturn False\relse:\rreturn isSyt(left_.right, right_.left) and isSyt(left_.left, right_.right)\relse:\rreturn False\rreturn isSyt(root.left, root.right)\r  ","description":"","id":2,"section":"posts","tags":["二叉树","递归","leetCodeEasy"],"title":"LeetCode 面试题 28","uri":"https://Teletubby.github.io/zh/posts/leetcode-interview-problems-28/"},{"content":"LeetCode 面试题 01.07. 旋转矩阵 已收录在 my LeetCode 题目 给定一幅由 N × N 矩阵表示的图像，其中每个像素的大小为4字节，编写一种方法，将图像旋转90度。\n不占用额外内存空间能否做到？\n示例 # 1\r给定 matrix = [\r[1,2,3],\r[4,5,6],\r[7,8,9]\r],\r原地旋转输入矩阵，使其变为:\r[\r[7,4,1],\r[8,5,2],\r[9,6,3]\r]\r# 2\r给定 matrix =\r[\r[ 5, 1, 9,11],\r[ 2, 4, 8,10],\r[13, 3, 6, 7],\r[15,14,12,16]\r], 原地旋转输入矩阵，使其变为:\r[\r[15,13, 2, 5],\r[14, 3, 4, 1],\r[12, 6, 8, 9],\r[16, 7,10,11]\r]\r题目 方法一 仅使用 zip 代码实现 1 2 3 4 5 6  class Solution:\rdef rotate(self, matrix: List[List[int]]) -\u0026gt; None:\r\u0026#34;\u0026#34;\u0026#34;\rDo not return anything, modify matrix in-place instead.\r\u0026#34;\u0026#34;\u0026#34;\rmatrix[::] = zip(*matrix[::-1])\r  方法二 map \u0026amp; zip 代码实现 1 2 3 4 5 6 7  class Solution:\rdef rotate(self, matrix: List[List[int]]) -\u0026gt; None:\r\u0026#34;\u0026#34;\u0026#34;\rDo not return anything, modify matrix in-place instead.\r\u0026#34;\u0026#34;\u0026#34;\r# 1\r matrix[:] = list(map(list, zip(*matrix[::-1])))\r  方法三 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution:\rdef rotate(self, matrix: List[List[int]]) -\u0026gt; None:\r\u0026#34;\u0026#34;\u0026#34;\rDo not return anything, modify matrix in-place instead.\r\u0026#34;\u0026#34;\u0026#34;\r# 2\r n = len(matrix)\rif n \u0026gt; 1:\rmatrix[:] = matrix[::-1]\rfor i in range(n-1):\rfor j in range(n):\rif i != j and i \u0026lt; j:\rmatrix[i][j],matrix[j][i] = matrix[j][i],matrix[i][j]\r  复杂度分析  时间复杂度: O(N^2) 空间复杂度 O(1)  ","description":"","id":3,"section":"posts","tags":["leetCodeMed"],"title":"LeetCode 面试题 01.07","uri":"https://Teletubby.github.io/zh/posts/leetcode-interview-problems-0107/"},{"content":"LeetCode 999. 可以被一步捕获的棋子数 已收录在 my LeetCode 题目 在一个 8 x 8 的棋盘上，有一个白色的车（Rook），用字符 \u0026lsquo;R\u0026rsquo; 表示。棋盘上还可能存在空方块，白色的象（Bishop）以及黑色的卒（pawn），分别用字符 \u0026lsquo;.'，'B\u0026rsquo; 和 \u0026lsquo;p\u0026rsquo; 表示。不难看出，大写字符表示的是白棋，小写字符表示的是黑棋。\n车按国际象棋中的规则移动。东，西，南，北四个基本方向任选其一，然后一直向选定的方向移动，直到满足下列四个条件之一：\n 棋手选择主动停下来。 棋子因到达棋盘的边缘而停下。 棋子移动到某一方格来捕获位于该方格上敌方（黑色）的卒，停在该方格内。 车不能进入/越过已经放有其他友方棋子（白色的象）的方格，停在友方棋子前。  你现在可以控制车移动一次，请你统计有多少敌方的卒处于你的捕获范围内（即，可以被一步捕获的棋子数）。\n示例 输入：[[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;R\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;p\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;]]\r输出：3\r解释：\r在本例中，车能够捕获所有的卒。\r输入：[[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;R\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;]]\r输出：0\r解释：\r象阻止了车捕获任何卒。\r输入：[[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;R\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;p\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;]]\r输出：0\r解释：\r象阻止了车捕获任何卒。\r留意  board.length == board[i].length == 8 board[i][j] 可以是 \u0026lsquo;R\u0026rsquo;，'.'，\u0026lsquo;B\u0026rsquo; 或 \u0026lsquo;p\u0026rsquo; 只有一个格子上存在 board[i][j] == \u0026lsquo;R\u0026rsquo;  题解 方法一 正则表达式 正则表达式\n代码实现 1 2 3 4 5 6 7 8 9  import re\rclass Solution:\rdef numRookCaptures(self, board: List[List[str]]) -\u0026gt; int:\rres=0\rfor i in board+list(zip(*board)):\rs=\u0026#39;\u0026#39;.join(i)\rres+=bool(re.search(r\u0026#39;p\\.*R\u0026#39;,s))\rres+=bool(re.search(r\u0026#39;R\\.*p\u0026#39;,s))\rreturn res\r  方法二 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  class Solution:\rdef numRookCaptures(self, board: List[List[str]]) -\u0026gt; int:\rfor i in range(8):\rfor j in range(8):\rif board[i][j] == \u0026#34;R\u0026#34;:\rbreak\rif board[i][j] == \u0026#34;R\u0026#34;:\rbreak\rup = down = left = right = 0\rdown_flag = right_flag = True\rfor m in range(8):\rif m \u0026lt; i:\rif board[m][j] == \u0026#34;p\u0026#34;:\rup = 1\relif board[m][j] == \u0026#34;B\u0026#34;:\rup = 0\relif m \u0026gt; i and down_flag:\rif board[m][j] == \u0026#34;p\u0026#34;:\rdown = 1\relif board[m][j] == \u0026#34;B\u0026#34;:\rdown_flag = False\rfor n in range(8):\rif n \u0026lt; j:\rif board[i][n] == \u0026#34;p\u0026#34;:\rleft = 1\relif board[i][n] == \u0026#34;B\u0026#34;:\rleft = 0\relif n \u0026gt; j and right_flag:\rif board[i][n] == \u0026#34;p\u0026#34;:\rright = 1\relif board[i][n] == \u0026#34;B\u0026#34;:\rright_flag = False\rreturn up+down+left+right\r  复杂度分析  时间复杂度: O(N) 空间复杂度: O(1)  ","description":"","id":4,"section":"posts","tags":["正则表达式","leetCodeEasy"],"title":"LeetCode 999","uri":"https://Teletubby.github.io/zh/posts/leetcode-999/"},{"content":"蔡勒公式 (Zeller\u0026rsquo;s Congruence) 蔡勒公式 是一种计算任何一日属一星期中哪一日的算法，由德国数学家 克里斯提安·蔡勒 推算出来。\n公式  原版公式后面是没有 $-1$ 的，西方通常以星期日作为一个星期的第一天，在ISO的版本则出现 $-1$。\n $$\nw = (y + \\lfloor\\frac{y}{4}\\rfloor + \\lfloor\\frac{c}{4}\\rfloor - 2c + \\lfloor\\frac{13(m + 1)}{5}\\rfloor + d - 1) \\ mod \\ 7\n$$\n或者\n$$\nw = (y + \\lfloor\\frac{y}{4}\\rfloor + \\lfloor\\frac{c}{4}\\rfloor - 2c + 2m + \\lfloor\\frac{3(m + 1)}{5}\\rfloor + d + 1) \\ mod \\ 7\n$$\n公式都是基于公历的置闰规则来考虑。\n公式中的符号含义如下：\n w 星期（计算所得的数值对应的星期：0-星期日；1-星期一；2-星期二；3-星期三；4-星期四；5-星期五；6-星期六） c 年份前两位数 y 年份后两位数 m 月（m的取值范围为3至14，即在蔡勒公式中，某年的1、2月要看作上一年的13、14月来计算，比如2003年1月1日要看作2002年的13月1日来计算） d 日 $\\lfloor\u0026hellip;\\rfloor$ 称作高斯符号，代表向下取整，即，取不大于原数的最大整数。 mod 同余（这里代表括号里的答案除以7后的余数）  注意 因为\n$$\n(y + \\lfloor\\frac{y}{4}\\rfloor + \\lfloor\\frac{c}{4}\\rfloor - 2c + \\lfloor\\frac{26(m + 1)}{10}\\rfloor + d - 1)\n$$\n可能为负数，所以当出现负数的情况下不能直接mod 7。编写成代码的时候如果两个操作数中只有一个负数，求模的结果取决于机器，也就是说某些情况下w在一些机器上为负数，但是在某一些机器上w不一定为负数（例如：21%-5的结果取决于机器，可能得到1或-4），对于产生负数这种情况可将原来公式分为两步：\n$$\n\\begin{aligned}\n\u0026amp; w = (y + \\lfloor\\frac{y}{4}\\rfloor + \\lfloor\\frac{c}{4}\\rfloor - 2c + \\lfloor\\frac{26(m + 1)}{10}\\rfloor + d - 1) \\\\\n\u0026amp; w = (w \\% 7 + 7) \\% 7\n\\end{aligned}\n$$\n参考  维基百科-蔡勒公式\n维基百科-取整函数\n ","description":"","id":5,"section":"posts","tags":["蔡勒公式"],"title":"蔡勒公式","uri":"https://Teletubby.github.io/zh/posts/math-zeller-congruence/"},{"content":"LeetCode 892. 三维形体的表面积 已收录在 my LeetCode 题目 在 N * N的网格上，我们放置一些 1 * 1 * 1 的立方体。\n每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。\n请你返回最终形体的表面积。\n示例 输入：[[2]]\r输出：10\r输入：[[1,2],[3,4]]\r输出：34\r输入：[[1,0],[0,2]]\r输出：16\r输入：[[1,1,1],[1,0,1],[1,1,1]]\r输出：32\r输入：[[2,2,2],[2,1,2],[2,2,2]]\r输出：46\r留意  1 \u0026lt;= N \u0026lt;= 50 0 \u0026lt;= grid[i][j] \u0026lt;= 50  题解 方法一 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Solution:\rdef surfaceArea(self, grid: List[List[int]]) -\u0026gt; int:\rres, N = 0, len(grid)\rfor i in range(N):\rfor j in range(N):\rif grid[i][j]:\rres += grid[i][j] * 4 + 2\rif i \u0026gt; 0:\rif grid[i][j] \u0026gt; grid[i-1][j]:\rres -= grid[i-1][j] * 2\relse:\rres -= grid[i][j] * 2\rif j \u0026gt; 0:\rif grid[i][j] \u0026gt; grid[i][j-1]:\rres -= grid[i][j-1] * 2\relse:\rres -= grid[i][j] * 2\rreturn res\r  复杂度分析  时间复杂度: O(N^2) 空间复杂度: O(1)  方法二 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution:\rdef surfaceArea(self, grid: List[List[int]]) -\u0026gt; int:\rcnt = mCnt = lCnt = tmp = 0\rfor row in grid:\rtmp = 0\rfor box in row:\rif box != 0:\rcnt += 1\rif box \u0026gt; tmp:\rmCnt += box - tmp\rtmp = box\rfor row in range(len(grid[0])):\rtmp = 0\rfor box in [i[row] for i in grid]:\rif box \u0026gt; tmp:\rlCnt += box - tmp\rtmp = box\rreturn (cnt + mCnt + lCnt) \u0026lt;\u0026lt; 1\r  复杂度分析 O(2*N^2) -\u0026gt; O(N^2)\n 时间复杂度: O(N^2) 空间复杂度: O(1)  方法三 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  from itertools import zip_longest\rimport numpy\rclass Solution:\rdef surfaceArea(self, grid: List[List[int]]) -\u0026gt; int:\rgridT = numpy.array(grid).T\rcnt = mCnt = lCnt = tmp = 0\rfor i in zip_longest(grid, gridT):\rif i[0]:\rll = i[0]\rwhile ll:\rt = ll.pop()\rif t != 0:\rcnt += 1\rmCnt += abs(t - tmp)\rtmp = t\rif len(ll) == 0:\rmCnt += t\rtmp = 0\rif i[1].any():\raa = list(i[1])\rwhile aa:\rt = aa.pop()\rlCnt += abs(t - tmp)\rtmp = t\rif len(aa) == 0:\rlCnt += t\rtmp = 0\rreturn (cnt \u0026lt;\u0026lt; 1) + mCnt + lCnt\r  复杂度分析 O(2*N^2) -\u0026gt; O(N^2)\n 时间复杂度: O(N^2) 空间复杂度: O(1)  ","description":"","id":6,"section":"posts","tags":["leetCodeEasy"],"title":"LeetCode 892","uri":"https://Teletubby.github.io/zh/posts/leetcode-892/"},{"content":"LeetCode 面试题 62. 圆圈中最后剩下的数字 已收录在 my LeetCode 题目 0,1,,n-1这 n 个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第 m 个数字。求出这个圆圈里剩下的最后一个数字。\n示例 输入: n = 5, m = 3\r输出: 3\r解释： 每次删除的数字依次是 2, 0, 4, 1, 所以最后留下的数字是 3\r输入: n = 10, m = 17\r输出: 2\r解释： 每次删除的数字依次是 6, 4, 5, 9, 7, 0, 1, 3, 8, 所以最后留下的数字是 2\r留意  1 \u0026lt;= n \u0026lt;= 10^5 1 \u0026lt;= m \u0026lt;= 10^6  题解 这道题和 约瑟夫排序. 有关，是个 约瑟夫环 问题。\n约瑟夫问题（有时也称为约瑟夫斯置换），是一个出现在计算机科学和数学中的问题。在计算机编程的算法中，类似问题又称为约瑟夫环。\n人们站在一个等待被处决的圈子里。 计数从圆圈中的指定点开始，并沿指定方向围绕圆圈进行。 在跳过指定数量的人之后，执行下一个人。 对剩下的人重复该过程，从下一个人开始，朝同一方向跳过相同数量的人，直到只剩下一个人，并被释放。\n代码实现 python\rcpp\r\r1 2 3 4 5 6  class Solution:\rdef lastRemaining(self, n: int, m: int) -\u0026gt; int:\rans = 0\rfor i in range(2, n + 1):\rans = (m + ans) % i\rreturn ans\r  \r\r1 2 3 4 5 6 7 8 9  class Solution {\rpublic:\rint lastRemaining(int n, int m) {\rint ans = 0;\rfor (int i = 2; i \u0026lt;= n; i++)\rans = (m + ans) % i;\rreturn ans;\r}\r};\r  \r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"c4695853e780ba77\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar codetabLinks = null;\rvar codetabContents = null;\rvar ids = [];\rif (containerElem) {\rcodetabLinks = containerElem.querySelectorAll('.codetab__link');\rcodetabContents = containerElem.querySelectorAll('.codetab__content');\r}\rfor (var i = 0; i 0) {\rcodetabContents[0].style.display = 'block';\r}\r 复杂度分析  时间复杂度: O(N) 空间复杂度 O(1)  参考  维基百科-约瑟夫问题\n ","description":"","id":7,"section":"posts","tags":["约瑟夫环","leetCodeEasy"],"title":"LeetCode 面试题 62.","uri":"https://Teletubby.github.io/zh/posts/leetcode-interview-problems-62/"},{"content":"下终南山过斛斯山人宿置酒[1]  李白\n 暮从碧山下[2]，山月随人归。\n却顾所来径[3]，苍苍横翠微[4]。\n相携及田家， 童稚开荆扉。\n绿竹入幽径， 青萝拂行衣[5]。\n欢言得所憩[6]，美酒聊共挥[7]。\n长歌吟松风[8]，曲尽河星稀[9]。\n我醉君复乐， 陶然共忘机[10]。\n作者简介 李白（701年－762年） ，字太白，号青莲居士，又号\u0026quot;谪仙人\u0026rdquo;，唐代伟大的浪漫主义诗人，被后人誉为\u0026quot;诗仙\u0026rdquo;，与杜甫并称为\u0026quot;李杜\u0026rdquo;，为了与另两位诗人李商隐与杜牧即\u0026quot;小李杜\u0026quot;区别，杜甫与李白又合称\u0026quot;大李杜\u0026rdquo;。\n创作背景 关于此诗的创作时间，有两种说法。一种说法是：李白作此诗时，正在长安供奉翰林。李白一生中曾两入长安，第一次是在唐玄宗开元十八年（730年），李白三十岁时；第二次是在天宝元年（742年），李白四十二岁时。此诗写于李白初入长安隐居终南山时期。\n另一种说法是：李白此诗作于唐玄宗天宝十一载（752年）春，时李白五十二岁，正隐居终南山。\n赏析 中国的田园诗以晋末陶潜为开山祖，他的诗，对后代影响很大。李白这首田园诗，似也有陶诗那种描写琐事人情，平淡爽直的风格。……\n注释  [1]终南山：又称南山，秦岭山峰之一，在今陕西省西安市南，唐时士子多隐居于此山。过：拜访。斛（hú）斯：复姓。山人：隐士。 [2]碧山：指终南山。下：下山。 [3]却顾：回头望。所来径：下山的小路。 [4]苍苍：一说是指灰白色，但这里不宜作此解，而应解释苍为苍翠、苍茫，苍苍叠用是强调群山在暮色中的那种苍茫貌。翠微：青翠掩映的山峦深处。此处指终南山。 [5]青萝：即女萝，攀缠在树枝上下垂的藤蔓。行衣：行人的衣服。 [6]得所憩：得到休息之所，指被人留宿。 [7]挥：举杯。 [8]松风：古乐府琴曲名，即《风入松曲》，此处也有歌声随风而入松林的意思。 [9]河星稀：银河中的星光稀微，谓夜已深。一作\u0026quot;星河稀\u0026rdquo;。 [10]陶然：欢乐的样子。忘机：道家语，忘记世俗的机心。此指心地旷达淡泊，与世无争。机，机巧之心。  参考  维基百科-李白\n百度百科-李白\n百度百科-下终南山过斛斯山人宿置酒\n ","description":"","id":8,"section":"posts","tags":["李白","五言古诗"],"title":"#4 《下终南山过斛斯山人宿置酒》","uri":"https://Teletubby.github.io/zh/posts/poems-day-4/"},{"content":"五言古诗 五言古诗，是汉、魏时期形成的一种新诗体。它没有一定的格律，不限长短，不讲平仄，用韵也相当自由，篇幅不限长短，但每句五个字的句式却是固定不变的。因为它既不同于汉代乐府歌辞，也不同于唐代的近体律诗和绝句，故称五言古诗。唐代的五言古诗虽源于汉、魏，但决不因袭模拟，呈现出自己的面貌，具有鲜明的时代特色。\n参考  百度百科-五言古诗\n维基百科-五言古诗\n ","description":"","id":9,"section":"posts","tags":["五言古诗"],"title":"五言古诗","uri":"https://Teletubby.github.io/zh/posts/five-character-poem/"},{"content":" 我的 python 版本 是 3.7\n 排序算法 已收录在 python daily tips 排序算法是用来根据元素上的比较运算符来对给定的数组或列表元素进行重新排序的。比较运算符是用来确定各个数据结构中元素的新顺序。\n顺便告诉你，Python 中 list.sort() 的默认实现是 Timsort\n几种简单常见的排序算法  冒泡排序 选择排序 插入排序 希尔排序 快速排序 归并排序 堆排序  冒泡排序 这是一个很简单的排序算法。通过遍历一个数组，将其中元素依次成对 (相邻的两元素) 比较，如果大小不同，则互相交换，直到最大元素\u0026quot;冒泡\u0026quot;到数组尾部、最小元素待在\u0026quot;底部\u0026rdquo;(数组头部)。\n next time\n 选择排序  next time\n 插入排序  next time\n 希尔排序  next time\n 快速排序  next time\n 归并排序  next time\n 堆排序 堆排序是一种较流行的排序技巧，基于 二叉堆(或二叉树) 数据结构。\n以升序排序说明，把数组转换成最大堆(max-heap)，这是一种满足最大堆性质的二叉树：对于除了根之外的每个节点i, A[parent(i)] ≥ A[i] (父节点大于等于子节点)。\n重复从最大堆取出数值最大的节点(把根节点和最后一个节点交换，把交换后的最后一个节点移出堆)，并让剩下的堆继续维持最大堆性质。直到堆中所有的元素都被移出，其返回结果就是排序后的数组。\n所以总的来说，需要实现一下功能：\n 维持最大堆 （重要，max_heapify 维持最大堆性质） 堆的建立 堆排序  堆 先来简单的说说 堆 是什么，堆(Heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵完全二叉树的数组对象。堆总是满足下列性质：\n 堆中某个节点的值总是不大于或不小于其父节点的值； 堆总是一棵 完全二叉树。(一种特殊的 二叉树 )  将根节点最大的堆叫做 最大堆 或 大根堆，根节点最小的堆叫做 最小堆 或 小根堆。常见的堆有二叉堆、斐波那契堆等。\n如下所示，用数组表示堆，父节点、子节点都对应的存放的数组中。\n同时可以得到一个公式：\n$$\n\\begin{cases}\n\u0026amp; parent \u0026amp; = \u0026amp; \\lfloor (i - 1) / 2 \\rfloor \\\\\n\u0026amp; leftChild \u0026amp; = \u0026amp; 2i + 1 \\\\\n\u0026amp; rightChild \u0026amp; = \u0026amp; 2i + 2\n\\end{cases}\n$$\n可以知道父节点与子节点之间的关系\n实现 maxHeapify() 这里使用 递归 实现\n先写出两个子节点，leftChild \u0026amp; rightChild。\n1 2 3 4  def maxHeapify(arr, i, end):\rleftChild = (i \u0026lt;\u0026lt; 1) + 1\rrightChild = leftChild + 1\r...\r  因为是实现大根堆，根节点是最大的。所以每次调整父节点时需要和子节点作比较，较大者的下标用 maxm 暂存，表示临时最大值的下标。\n同时在计算子节点的时候，有可能会超出数组的范围，所以在比较子节点与父节点的大小之前，需要进行判断。\n倘若根节点在其子节点中不是最大值的话，即临时最大值下标 maxm 不等于父节点下标 i ，则交换下标，并向上递归。\n1 2 3 4 5 6 7 8 9 10  # maxHeapify(arr, root, end)\r ...\rmaxm = i\rif leftChild \u0026lt; end and arr[leftChild] \u0026gt; arr[maxm]:\rmaxm = leftChild\rif rightChild \u0026lt; end and arr[rightChild] \u0026gt; arr[maxm]:\rmaxm = rightChild\rif maxm != i:\rarr[maxm], arr[i] = arr[i], arr[maxm]\rmaxHeapify(arr, maxm, end)\r  实现 buildHeap() 由图不难发现，我们可以通过 最后一个节点 求得其父节点然后对当前子树进行最大堆化（max heapify）\n之后再对下一棵子树最大堆化，直到根节点。\n1 2 3 4  def buildHeap(arr, n):\rfor i in range(((n-2) \u0026gt;\u0026gt; 1), -1, -1):\rmaxHeapify(arr, i, n)\rreturn arr\r  写完后可以结合之前的 maxHeapify()，对一个数组或列表进行 大根堆 化。\n测试 1 2 3 4 5  a = [2, 4, 1, 6, 3, 8, 9, 5, 0, 4]\rn = len(a)\rbuildHeap(a, n)\rOUTPUT: [9, 6, 8, 5, 4, 2, 1, 4, 0, 3]\r  测试结果符合 大根堆 的定义。\n实现 heapSort() 到了完成堆排序代码的最后一步了，经过之前的代码已经可以将一个数组构造成一个大根堆了。\n现在只需要按顺序取值就行了。因为根据大根堆的性质，每个父节点都比其子节点的值大。所以我们每次将根节点与堆最后的节点进行互换，根节点肯定是当前堆中最大的值，而堆最后的节点只可能小于等于根节点，互换后，此时当前堆不是大根堆，需要进行维持最大堆（max heapify），然后重复上述操作直到堆为空。\n1 2 3 4 5 6  def heapSort(arr, n):\rn = len(arr)\rbuildHeap(arr, n)\rfor i in range(n-1, -1, -1):\rarr[i], arr[0] = arr[0], arr[i] # exchange\r maxHeapify(arr, 0, i)\r  完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  def maxHeapify(arr, i, n):\rleftChild = (i \u0026lt;\u0026lt; 1) + 1\rrightChild = leftChild + 1\rmaxm = i\rif leftChild \u0026lt; n and arr[leftChild] \u0026gt; arr[maxm]:\rmaxm = leftChild\rif rightChild \u0026lt; n and arr[rightChild] \u0026gt; arr[maxm]:\rmaxm = rightChild\rif maxm != i:\rarr[maxm], arr[i] = arr[i], arr[maxm]\rmaxHeapify(arr, maxm, n)\rdef buildHeap(arr, n):\rfor i in range(((n-2) \u0026gt;\u0026gt; 1), -1, -1):\rmaxHeapify(arr, i, n)\rreturn arr\rdef heapSort(arr):\rn = len(arr)\rbuildHeap(arr, n)\rfor i in range(n-1, -1, -1):\rarr[i], arr[0] = arr[0], arr[i]\rmaxHeapify(arr, 0, i)\ra = [2, 4, 1, 6, 3, 8, 9, 5, 0, 4]\rheapSort(a)\rprint(a)\r  时间复杂度 maxHeapify 函数遍历树的时间复杂度是 O(log(n))。\nheapSort 函数需要对数组迭代 n 次，因此 Heap Sort 算法总的时间复杂度是 O(nlog(n))。\n空间复杂度 堆排序的空间复杂度为 O(1)\n参考  Wikipedia-SortingAlgorithm\nGeeksforGeeks-SortingAlgorithm\n百度百科-堆\n维基百科-堆\n维基百科-二叉树\n ","description":"","id":10,"section":"posts","tags":["二叉树","python"],"title":"Python 排序算法","uri":"https://Teletubby.github.io/zh/posts/python-sorting-algorithms/"},{"content":"感遇  张九龄\n 【其一】\n兰叶春葳蕤[1]，桂华秋皎洁。\n欣欣此生意， 自尔为佳节。\n谁知林栖者[2]，闻风坐相悦[3]。\n草木有本心[4]，何求美人折[5]。\n【其七】\n江南有丹橘， 经冬犹绿林。\n岂伊地气暖， 自有岁寒心[6]。\n可以荐嘉客[7]，奈何阻重深。\n运命唯所遇， 循环不可寻。\n徒言树桃李[8]，此木岂无阴。\n作者简介 张九龄（678—740），唐朝大臣。字子寿，一名博物，韶州曲江（今广东韶关）人。景龙（唐中宗年号，707—710）初年进士。唐玄宗时历官中书侍郎、同中书门下平章事、中书令，是唐朝有名的贤相。公元736年（开元二十四年）为李林甫所谮，罢相。其《感遇诗》以格调刚健著称。\n创作背景 唐玄宗开元二十五年（737年），张九龄由尚书丞相贬为荆州长史。晚年遭馋毁，忠而被贬，\u0026ldquo;每读韩非《孤愤》，涕泣沾襟\u0026rdquo;（徐浩《张公神道碑》），遂作《感遇十二首》。\n赏析 《唐诗品汇》：高廷礼曰：神龙以还，品格渐高，颇通远调。前论沈、宋比肩，后称燕、许手笔，又如薛少保之《郊陕篇》、张曲江公《感遇》等作，雅正冲澹，体合风骚，骎骎乎盛唐矣。……\n注释  [1]葳蕤：枝叶茂盛而纷披的样子。华，同\u0026quot;花\u0026rdquo;，花朵。 [2]林栖者：生活在山林之中的人，这里指隐士。 [3]坐：因而。 [4]本心：天性。 [5]美人：喻指理想中的同道者。 [6]伊：语助词。岁寒心：意即耐寒的特性。 [7]荐：进奉意。 [8]树：种植意。  参考  维基百科-张九龄\n百度百科-张九龄\n百度百科-感遇十二首\n ","description":"","id":11,"section":"posts","tags":["张九龄","五言古诗"],"title":"#3 《感遇》二首","uri":"https://Teletubby.github.io/zh/posts/poems-day-3/"},{"content":"LeetCode 365. 水壶问题 已收录在 my LeetCode 题目 有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？\n如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。\n你允许：\n 装满任意一个水壶 倒空任意一个水壶 从一个水壶向另外一个水壶倒水，直到装满或者倒空  示例 输入: x = 3, y = 5, z = 4\r输出: True\r输入: x = 2, y = 6, z = 5\r输出: False\r留意 来自著名的 \u0026ldquo;虎胆龙威3\u0026rdquo; 中的倒水例子\n题解 方法一 贝祖定理 贝祖定理\n代码实现 1 2 3 4 5 6 7  class Solution:\rdef canMeasureWater(self, x: int, y: int, z: int) -\u0026gt; bool:\rif x + y \u0026lt; z:\rreturn False\rif x == 0 or y == 0:\rreturn z == 0 or x + y == z\rreturn z % math.gcd(x, y) == 0\r  复杂度分析  时间复杂度: O(log(min(x,y))) 取决于求最大公约数的算法。 空间复杂度: O(1)  方法二 深度优先搜索  有时间就填上\n 方法三 广度优先搜索  有时间就补上\n ","description":"","id":12,"section":"posts","tags":["最大公约数","深度优先搜索","广度优先搜索","贝祖定理","leetCodeMed"],"title":"LeetCode 365","uri":"https://Teletubby.github.io/zh/posts/leetcode-365/"},{"content":"LeetCode 面试题 17.16. 按摩师 已收录在 my LeetCode 题目  另一道差不多的题。 打家劫舍, here is LeetCode portal\n 一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。\n示例 输入： [1,2,3,1]\r输出： 4\r解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。\r输入： [2,7,9,3,1]\r输出： 12\r解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。\r输入： [2,1,4,5,3,1,1,3]\r输出： 12\r解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。\r题解 别以为你穿了个马甲我就不认识你了。上次还在打家劫舍，现在就金盆洗手做按摩师了。\n动态规划\n代码实现 1 2 3 4 5 6  class Solution:\rdef rob(self, nums: List[int]) -\u0026gt; int:\rmaxm = pre = 0\rfor num in nums:\rmaxm,pre = max(maxm, num+pre),maxm\rreturn maxm\r  复杂度分析  时间复杂度: O(N) 空间复杂度 O(1)  ","description":"","id":13,"section":"posts","tags":["动态规划","leetCodeEasy"],"title":"LeetCode 面试题 17.16","uri":"https://Teletubby.github.io/zh/posts/leetcode-interview-problems-1716/"},{"content":"LeetCode 204. 计数质数 已收录在 my LeetCode 题目 统计所有小于非负整数 n 的质数的数量。\n示例 输入: 10\r输出: 4\r解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。\r题解 埃拉托斯特尼筛法.\n代码实现 1 2 3 4 5 6 7 8 9 10 11  class Solution:\rdef countPrimes(self, n: int) -\u0026gt; int:\rif n \u0026lt; 2:\rreturn 0\rIsPrime = [True] * n\rfor i in range(2, int(n ** 0.5) + 1):\rif IsPrime[i]:\rtmp = i*i\rIsPrime[tmp : n : i] = [False] * len(IsPrime[tmp : n : i])\rreturn sum(IsPrime)-2\r  ","description":"","id":14,"section":"posts","tags":["埃拉托斯特尼筛法","leetCodeEasy"],"title":"LeetCode 204","uri":"https://Teletubby.github.io/zh/posts/leetcode-204/"},{"content":"LeetCode 876. 链表的中间结点 已收录在 my LeetCode 题目 给定一个带有头结点 head 的非空单链表，返回链表的中间结点。\n如果有两个中间结点，则返回第二个中间结点。\n示例 输入：[1,2,3,4,5]\r输出：此列表中的结点 3 (序列化形式：[3,4,5])\r返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。\r注意，我们返回了一个 ListNode 类型的对象 ans，这样：\rans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.\r输入：[1,2,3,4,5,6]\r输出：此列表中的结点 4 (序列化形式：[4,5,6])\r由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。\r留意  给定链表的结点数介于 1 和 100 之间。  题解 方法一 快慢指针\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13  # Definition for singly-linked list.\r # class ListNode:\r # def __init__(self, x):\r # self.val = x\r # self.next = None\r class Solution:\rdef middleNode(self, head: ListNode) -\u0026gt; ListNode:\rfast = slow = head\rwhile fast and fast.next:\rfast = fast.next.next\rslow = slow.next\rreturn slow\r  复杂度分析  时间复杂度: O(N) 空间复杂度: O(1)  方法二  太晚了，先占个坑，下次写😂\n 代码实现 1 2 3 4 5 6 7 8 9 10 11 12  # Definition for singly-linked list.\r # class ListNode:\r # def __init__(self, x):\r # self.val = x\r # self.next = None\r class Solution:\rdef middleNode(self, head: ListNode) -\u0026gt; ListNode:\rans = [head]\rwhile ans[-1].next:\rans.append(ans[-1].next)\rreturn ans[len(ans) // 2]\r  复杂度分析  时间复杂度: O(N) 空间复杂度: O(N)  ","description":"","id":15,"section":"posts","tags":["双指针","leetCodeEasy"],"title":"LeetCode 876","uri":"https://Teletubby.github.io/zh/posts/leetcode-876/"},{"content":"LeetCode 1071. 字符串的最大公因子 已收录在 my LeetCode 题目 对于字符串 S 和 T，只有在 S = T + \u0026hellip; + T（T 与自身连接 1 次或多次）时，我们才认定 \u0026ldquo;T 能除尽 S\u0026quot;。\n返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。\n示例 输入：str1 = \u0026quot;ABCABC\u0026quot;, str2 = \u0026quot;ABC\u0026quot;\r输出：\u0026quot;ABC\u0026quot;\r输入：str1 = \u0026quot;ABABAB\u0026quot;, str2 = \u0026quot;ABAB\u0026quot;\r输出：\u0026quot;AB\u0026quot;\r输入：str1 = \u0026quot;LEET\u0026quot;, str2 = \u0026quot;CODE\u0026quot;\r输出：\u0026quot;\u0026quot;\r留意  1 \u0026lt;= str1.length \u0026lt;= 1000 1 \u0026lt;= str2.length \u0026lt;= 1000 str1[i] and str2[i] 为大写英文字母  题解  占个坑 😜，有时间再补\n 代码实现 1 2 3 4 5  class Solution:\rdef gcdOfStrings(self, str1: str, str2: str) -\u0026gt; str:\rif str1 + str2 != str2 + str1:\rreturn \u0026#39;\u0026#39;\rreturn str1[: math.gcd(len(str1), len(str2))]\r  ","description":"","id":16,"section":"posts","tags":["最大公约数","leetCodeEasy"],"title":"LeetCode 1071","uri":"https://Teletubby.github.io/zh/posts/leetcode-1071/"},{"content":"LeetCode 198. 打家劫舍 已收录在 my LeetCode 题目  另一道差不多的题。 面试题 17.16. 按摩师, 这是 力扣原题传送门\n 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下，能够偷窃到的最高金额。\n示例 输入: [1,2,3,1]\r输出: 4\r解释:\r偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\r偷窃到的最高金额 = 1 + 3 = 4 。\r输入: [2,7,9,3,1]\r输出: 12\r解释:\r偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\r偷窃到的最高金额 = 2 + 9 + 1 = 12 。\r题解  先占个坑. 😜\n 代码实现 1 2 3 4 5 6  class Solution:\rdef rob(self, nums: List[int]) -\u0026gt; int:\rmaxm = pre = 0\rfor num in nums:\rmaxm,pre = max(maxm, num+pre),maxm\rreturn maxm\r  复杂度分析 N 是房屋的数量\n 时间复杂度: O(N) 空间复杂度: O(1)  ","description":"","id":17,"section":"posts","tags":["动态规划","leetCodeEasy"],"title":"LeetCode 198","uri":"https://Teletubby.github.io/zh/posts/leetcode-198/"},{"content":"最大公约数  先占个坑 😜\n ","description":"","id":18,"section":"posts","tags":["最大公约数"],"title":"关于最大公约数","uri":"https://Teletubby.github.io/zh/posts/math-gcd/"},{"content":"LeetCode 914. 卡牌分组 已收录在 my LeetCode 题目 给定一副牌，每张牌上都写着一个整数。\n此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：\n 每组都有 X 张牌。 组内所有的牌上都写着相同的整数。  仅当你可选的 X \u0026gt;= 2 时返回 true。\n示例 输入：[1,2,3,4,4,3,2,1]\r输出：true\r解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]\r输入：[1,1,1,2,2,2,3,3]\r输出：false\r解释：没有满足要求的分组。\r输入：[1]\r输出：false\r解释：没有满足要求的分组。\r输入：[1,1]\r输出：true\r解释：可行的分组是 [1,1]\rI输入：[1,1,2,2,2,2]\r输出：true\r解释：可行的分组是 [1,1]，[2,2]，[2,2]\r留意  1 \u0026lt;= deck.length \u0026lt;= 10^4 0 \u0026lt;= deck[i] \u0026lt; 10^4  题解 Counter \u0026amp; GCD(最大公约数), 应该还比较容易理解~\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class Solution:\rdef hasGroupsSizeX(self, deck: List[int]) -\u0026gt; bool:\r# v2.0 没用 Counter 和 gcd 的写法\r d = {}\rfor num in deck:\rd[num] = d.setdefault(num, 0) + 1\rcounter = list(d.values())\rif 1 in counter:\rreturn False\rfor i in range(2, max(counter)+1):\rfor j in counter:\rif j % i != 0:\rbreak\relse:\rreturn True\rreturn False\r# v1.1 比 v1.0 快些\r \u0026#39;\u0026#39;\u0026#39;\rcounter = Counter(deck).values()\rif 1 in counter:\rreturn False\rreturn functools.reduce(math.gcd,counter) \u0026gt;= 2\r\u0026#39;\u0026#39;\u0026#39;\r# v1.0\r \u0026#39;\u0026#39;\u0026#39;\rreturn functools.reduce(math.gcd, Counter(deck).values()) \u0026gt;= 2\r\u0026#39;\u0026#39;\u0026#39;\r  复杂度分析 N 是卡牌的个数，C 是 deck[i] 的取值范围（本题中是10000）。\n求两个数的 最大公约数 的时间复杂度是 O(logC)，最多需要求 N - 1 次。\n 时间复杂度: O(NlogC) 空间复杂度: O(N)  ","description":"","id":19,"section":"posts","tags":["最大公约数","leetCodeEasy"],"title":"LeetCode 914","uri":"https://Teletubby.github.io/zh/posts/leetcode-914/"},{"content":" 我的 python 版本 是 3.7\n 如何跳出多层循环 已收录在 python daily tips 自定义异常 1 2 3 4 5 6 7 8 9 10 11  class GetOutOfLoop(Exception):\rpass\rtry:\rfor i in range(5):\rfor j in range(5):\rif i == j == 2:\rraise GetOutOfLoop()\relse:\rprint(i,\u0026#39;----\u0026#39;, j)\rexcept GetOutOfLoop:\rpass\r  将多层循环封装成函数 1 2 3 4 5 6 7 8 9  def test():\rfor i in range(5):\rfor j in range(5):\rif i == j == 2:\rreturn\relse:\rprint(i,\u0026#39;----\u0026#39;, j)\rtest()\r  使用 for-else 语句 更多关于如何使用 for-else 语句。\n1 2 3 4 5 6 7 8 9 10 11 12 13  for i in range(5):\rfor j in range(5):\rfor k in range(5):\rif i == j == k == 3:\rbreak # break k loop\r else: print(i, \u0026#39;----\u0026#39;, j, \u0026#39;----\u0026#39;, k)\relse: #1 else1\r continue\rbreak #1 break j loop\r else: #2 else2\r continue\rbreak #2 break i loop\r   ","description":"","id":20,"section":"posts","tags":["python"],"title":"Python 如何跳出多层循环","uri":"https://Teletubby.github.io/zh/posts/python-break-loop/"},{"content":"瀑布联句  李枕，香严闲禅师\n 千岩万壑不辞劳，远看方知出处高。\n溪涧岂能留得住，终归大海作波涛。\n作者简介 李忱（810— 859年），即唐宣宗，宪宗第十三子。初名怡，即位日改名忱。穆宗长庆元年（821年）封光王，武宗会昌六年（846年）即位，改元年号大中。卒谥文献。\n香严闲禅师：庐山上高僧。\n创作背景 此诗具体创作时间未知。唐宣宗李忱因母亲地位卑下，侄子文宗、武宗常把他当成小丑戏耍。他用无言对待各种加诸于他的猜忌、打击，在艰难困苦中默默地忍受，但他并没有消沉。他逃避人世做了僧人。游行江淮，寻访名山禅院，一日，遇黄檗禅师，（据《佛祖统纪》应为香严闲禅师。因宣宗上庐山时黄檗在海昌，不可能联句）并与之同行，\u0026ldquo;因观瀑布。黄檗曰：‘我咏此得一联，而下韵不接。’宣宗曰：‘ 当为续成之。’\u0026ldquo;遂有《瀑布联句》。\n赏析 此诗的作者是一位皇帝和一位僧侣。禅师作前两句，有暗射宣宗当时处境用意；宣宗续后两句，则寄寓不甘落寞、思有作为的情怀。这样一首托物言志的诗，描绘了冲决一切、气势磅礴的瀑布的艺术形象，富有激情，读来使人激奋，受到鼓舞，艺术形象往往大于作者思想，这也是一个显例。……\n参考  品诗文网-瀑布联句\n百度百科-瀑布联句\n ","description":"","id":21,"section":"posts","tags":["李枕"],"title":"#2 《瀑布联句》","uri":"https://Teletubby.github.io/zh/posts/poems-day-2/"},{"content":"宣州谢昭楼饯别校书叔云  李白\n 弃我去者，昨日之日不可留。\n乱我心者，今日之日多烦忧。\n长风万里送秋雁，对此可以酣高楼。\n蓬莱文章建安骨，中间小谢又清发。\n俱怀逸兴壮思飞，欲上青天揽明月。\n抽刀断水水更流，举杯消愁愁更愁。\n人生在世不称意，明朝散发弄扁舟。\n作者简介 李白（701年－762年） ，字太白，号青莲居士，又号\u0026quot;谪仙人\u0026rdquo;，唐代伟大的浪漫主义诗人，被后人誉为\u0026quot;诗仙\u0026rdquo;，与杜甫并称为\u0026quot;李杜\u0026rdquo;，为了与另两位诗人李商隐与杜牧即\u0026quot;小李杜\u0026quot;区别，杜甫与李白又合称\u0026quot;大李杜\u0026rdquo;。\n创作背景 这首诗作于安史之乱前不久。大约是在公元753年（天宝十二载,天宝末年）的秋天，李白来到宣州，客居宣州不久，他的一位故人李云行至此，很快又要离开，李白陪他登谢脁楼，设宴送行。宣州谢脁楼（一称谢脁楼或谢公楼，唐末改称叠嶂楼）是南齐诗人谢脁任宣城（今安徽省宣城县）太守时所建。李白曾多次登临，并写过一首《秋登宣城谢脁北楼》。\n赏析 这是一首饯别抒怀诗。在诗中，诗人感怀万端，既满怀豪情逸兴，又时时掩抑不住郁闷与不平，感情回复跌宕，一波三折，表达了自己遗世高蹈的豪迈情怀。……\n参考  维基百科-李白\n百度百科-李白\n李白诗歌网-宣州谢脁楼饯别校书叔云\n品诗文网-宣州谢脁楼饯别校书叔云\n ","description":"","id":22,"section":"posts","tags":["李白"],"title":"#1 《宣州谢昭楼饯别校书叔云》","uri":"https://Teletubby.github.io/zh/posts/poems-day-1/"},{"content":"LeetCode 300. 最长上升子序列 已收录在 my LeetCode 题目 给定一个无序的整数数组，找到其中最长上升子序列的长度。\n示例 输入: [10,9,2,5,3,7,101,18]\r输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。\r注意  可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(N^2)。  进阶 你能将算法的时间复杂度降低到 O(NlogN) 吗?\n题解 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Solution:\rdef lengthOfLIS(self, nums: List[int]) -\u0026gt; int:\r\u0026#39;\u0026#39;\u0026#39;numsLen = len(nums)\rif numsLen \u0026lt; 2:\rreturn numsLen\u0026#39;\u0026#39;\u0026#39;\rdp = []\rans = 0\rfor n in nums:\rif ans \u0026lt; 1 or n \u0026gt; dp[-1]:\rdp.append(n)\rans += 1\relse:\rlow, high = 0, ans - 1\rwhile low \u0026lt; high:\rmid = (low + high) // 2\rif dp[mid] \u0026gt;= n:\rhigh = mid\relse:\rlow = mid + 1\rdp[high] = n\rreturn ans\r  复杂度分析 nums 的长度为 N ，依次用数组中的元素去更新 dp，而更新 dp 数组时需要进行二分查找 (时间复杂度为 O(logN))。\n 时间复杂度: O(NlogN) 空间复杂度: O(N)  ","description":"","id":23,"section":"posts","tags":["动态规划","二分查找","leetCodeMed"],"title":"LeetCode 300","uri":"https://Teletubby.github.io/zh/posts/leetcode-300/"},{"content":"LeetCode 945. 使数组唯一的最小增量 已收录在 my LeetCode 题目 给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。\n返回使 A 中的每个值都是唯一的最少操作次数。\n示例 输入：[1,2,2]\r输出：1\r解释：\r经过一次 move 操作，数组将变为 [1, 2, 3]。\r输入：[3,2,1,2,1,7]\r输出：6\r解释：\r经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。\r可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。\r留意  0 \u0026lt;= A.length \u0026lt;= 40000 0 \u0026lt;= A[i] \u0026lt; 40000  题解 方法一 贪心算法 贪心算法\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution:\rdef minIncrementForUnique(self, A: List[int]) -\u0026gt; int:\rif not A:\rreturn 0\rA.sort()\rp = A[0]\rcnt = 0\rfor i in A[1:]:\rif p \u0026gt;= i:\rp += 1\rcnt += p - i\relse:\rp = i\rreturn cnt\r  复杂度分析  时间复杂度: O(NlogN) 空间复杂度: O(N)  方法二 线性探测（含路径压缩）\n 待补坑\n 复杂度分析  时间复杂度: O(N) 空间复杂度: O(N)  ","description":"","id":24,"section":"posts","tags":["贪心算法","leetCodeMed"],"title":"LeetCode 945","uri":"https://Teletubby.github.io/zh/posts/leetcode-945/"},{"content":" My python version is 3.7\n timeit - 测量小代码片段的执行时间 已收录在 python daily tips 该模块提供了一种简单的方法来计算一小段 Python 代码的耗时。它避免了许多用于测量执行时间的常见陷阱。\n这可以通过 命令行界面 和 Python接口 来实现。\n这里只讨论 python接口.\npython 接口 该模块定义了三个便利函数和一个公共类：\n timeit.timeit(stmt='pass\u0026rsquo;, setup='pass\u0026rsquo;, timer=, number=1000000, globals=None) timeit.repeat(stmt='pass\u0026rsquo;, setup='pass\u0026rsquo;, timer=, repeat=5, number=1000000, globals=None) timeit.default_timer() class timeit.Timer(stmt='pass\u0026rsquo;, setup='pass\u0026rsquo;, timer=, globals=None)  timeit.timeit() 使用给定语句、 setup 代码和 timer 函数创建一个 Timer 实例，并执行 number 次其 timeit() 方法。可选的 globals 参数指定用于执行代码的命名空间。\n 在 3.5 版更改: 添加可选参数 globals。  timeit.repeat() 使用给定语句、 setup 代码和 timer 函数创建一个 Timer 实例，并使用给定的 repeat 计数和 number 执行运行其 repea() 方法。可选的 globals 参数指定用于执行代码的命名空间。\n 在 3.5 版更改: 添加可选参数 globals。 在 3.7 版更改: repeat 的默认值由 3 更改为 5。  timeit.default_timer() 默认的计时器，总是 time.perf_counter。\n 在 3.3 版更改: time.perf_counter() 现在是 默认计时器。  class timeit.Timer 用于小代码片段的计数执行速度的类。\n构造函数接受一个将计时的语句、一个用于设置的附加语句和一个定时器函数。两个语句都默认为 \u0026lsquo;pass\u0026rsquo; ；计时器函数与平台有关（请参阅模块文档字符串）。 stmt 和 setup 也可能包含多个以 ; 或换行符分隔的语句，只要它们不包含多行字符串文字即可。该语句默认在 timeit 的命名空间内执行；可以通过将命名空间传递给 globals 来控制此行为\n要测量第一个语句的执行时间，请使用 timeit() 方法。 repeat() 和 autorange() 方法是方便的方法来调用 timeit() 多次。\nsetup 的执行时间从总体计时执行中排除。\nstmt 和 setup 参数也可以使用不带参数的可调用对象。这将在一个计时器函数中嵌入对它们的调用，然后由 timeit() 执行。请注意，由于额外的函数调用，在这种情况下，计时开销会略大一些。\n 在 3.5 版更改: 添加可选参数 globals。  timeit(number=1000000) 执行 number 次主要语句。这将执行一次 setup 语句，然后返回执行主语句多次所需的时间，以秒为单位测量为浮点数。参数是通过循环的次数，默认为一百万。要使用的主语句、 setup 语句和 timer 函数将传递给构造函数。\n 注意\n默认情况下， timeit() 暂时关闭 garbage collection 。这种方法的优点在于它使独立时序更具可比性。缺点是GC可能是所测量功能性能的重要组成部分。如果是这样，可以在 setup 字符串中的第一个语句重新启用GC。例如:\ntimeit.Timer('for i in range(10): oct(i)', 'gc.enable()').timeit()\n autorange(callback=None) 自动决定调用多少次 timeit()。\n这是一个便利函数，它反复调用 timeit() ，以便总时间 \u0026gt;= 0.2 秒，返回最终（循环次数，循环所用的时间）。它调用 timeit() 的次数以序列 1, 2, 5, 10, 20, 50, \u0026hellip; 递增，直到所用的时间至少为0.2秒。\n如果给出 callback 并且不是 None ，则在每次试验后将使用两个参数调用它： callback(number, time_taken)。\n 3.6 版新功能。  repeat(repeat=5, number=1000000) 调用 timeit() 几次。\n这是一个方便的函数，它反复调用 timeit() ，返回结果列表。第一个参数指定调用 timeit() 的次数。第二个参数指定 timeit() 的 number 参数。\n Note\n从结果向量计算并报告平均值和标准差这些是很诱人的。但是，这不是很有用。在典型情况下，最低值给出了机器运行给定代码段的速度的下限；结果向量中较高的值通常不是由Python的速度变化引起的，而是由于其他过程干扰你的计时准确性。所以结果的 min() 可能是你应该感兴趣的唯一数字。之后，你应该看看整个向量并应用常识而不是统计。\n  在 3.7 版更改: repeat 的默认值由 3 更改为 5。  print_exc(file=None) 帮助程序从计时代码中打印回溯。\n典型使用:\n1 2 3 4 5  t = Timer(...) # outside the try/except\r try:\rt.timeit(...) # or t.repeat(...)\r except Exception:\rt.print_exc()\r  与标准回溯相比，优势在于将显示已编译模板中的源行。可选的 file 参数指向发送回溯的位置；它默认为 sys.stderr 。\n示例 基本示例\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; import timeit\r\u0026gt;\u0026gt;\u0026gt; timeit.timeit(\u0026#39;\u0026#34;-\u0026#34;.join(str(n) for n in range(100))\u0026#39;, number=10000)\r0.3018611848820001\r\u0026gt;\u0026gt;\u0026gt; timeit.timeit(\u0026#39;\u0026#34;-\u0026#34;.join([str(n) for n in range(100)])\u0026#39;, number=10000)\r0.2727368790656328\r\u0026gt;\u0026gt;\u0026gt; timeit.timeit(\u0026#39;\u0026#34;-\u0026#34;.join(map(str, range(100)))\u0026#39;, number=10000)\r0.23702679807320237\r  也可以传出一个可调用对象:\n1 2  \u0026gt;\u0026gt;\u0026gt; timeit.timeit(lambda: \u0026#34;-\u0026#34;.join(map(str, range(100))), number=10000)\r0.19665591977536678\r  可以提供一个在开头只执行一次的 setup 语句：\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; import timeit\r\u0026gt;\u0026gt;\u0026gt; timeit.timeit(\u0026#39;char in text\u0026#39;, setup=\u0026#39;text = \u0026#34;sample string\u0026#34;; char = \u0026#34;g\u0026#34;\u0026#39;)\r0.41440500499993504\r\u0026gt;\u0026gt;\u0026gt; timeit.timeit(\u0026#39;text.find(char)\u0026#39;, setup=\u0026#39;text = \u0026#34;sample string\u0026#34;; char = \u0026#34;g\u0026#34;\u0026#39;)\r1.7246671520006203\r  使用 Timer 类及其方法可以完成同样的操作:\n1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; import timeit\r\u0026gt;\u0026gt;\u0026gt; t = timeit.Timer(\u0026#39;char in text\u0026#39;, setup=\u0026#39;text = \u0026#34;sample string\u0026#34;; char = \u0026#34;g\u0026#34;\u0026#39;)\r\u0026gt;\u0026gt;\u0026gt; t.timeit()\r0.3955516149999312\r\u0026gt;\u0026gt;\u0026gt; t.repeat()\r[0.40183617287970225, 0.37027556854118704, 0.38344867356679524, 0.3712595970846668, 0.37866875250654886]\r  以下示例显示如何计算包含多行的表达式。 在这里我们对比使用 hasattr() 与 try/except 的开销来测试缺失与提供对象属性:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  \u0026gt;\u0026gt;\u0026gt; import timeit\r\u0026gt;\u0026gt;\u0026gt; # attribute is missing\r \u0026gt;\u0026gt;\u0026gt; s = \u0026#34;\u0026#34;\u0026#34;\\\r... try:\r... str.__bool__\r... except AttributeError:\r... pass\r... \u0026#34;\u0026#34;\u0026#34;\r\u0026gt;\u0026gt;\u0026gt; timeit.timeit(stmt=s, number=100000)\r0.9138244460009446\r\u0026gt;\u0026gt;\u0026gt; s = \u0026#34;if hasattr(str, \u0026#39;__bool__\u0026#39;): pass\u0026#34;\r\u0026gt;\u0026gt;\u0026gt; timeit.timeit(stmt=s, number=100000)\r0.5829014980008651\r\u0026gt;\u0026gt;\u0026gt;\r\u0026gt;\u0026gt;\u0026gt; # attribute is present\r \u0026gt;\u0026gt;\u0026gt; s = \u0026#34;\u0026#34;\u0026#34;\\\r... try:\r... int.__bool__\r... except AttributeError:\r... pass\r... \u0026#34;\u0026#34;\u0026#34;\r\u0026gt;\u0026gt;\u0026gt; timeit.timeit(stmt=s, number=100000)\r0.04215312199994514\r\u0026gt;\u0026gt;\u0026gt; s = \u0026#34;if hasattr(int, \u0026#39;__bool__\u0026#39;): pass\u0026#34;\r\u0026gt;\u0026gt;\u0026gt; timeit.timeit(stmt=s, number=100000)\r0.08588060699912603\r  要让 timeit 模块访问你定义的函数，你可以传递一个包含 import 语句的 setup 参数:\n1 2 3 4 5 6 7  def test():\r\u0026#34;\u0026#34;\u0026#34;Stupid test function\u0026#34;\u0026#34;\u0026#34;\rL = [i for i in range(100)]\rif __name__ == \u0026#39;__main__\u0026#39;:\rimport timeit\rprint(timeit.timeit(\u0026#34;test()\u0026#34;, setup=\u0026#34;from __main__ import test\u0026#34;))\r  另一种选择是将 globals() 传递给 globals 参数，这将导致代码在当前的全局命名空间中执行。这比单独指定 import 更方便\n1 2 3 4 5 6 7 8 9  def f(x):\rreturn x**2\rdef g(x):\rreturn x**4\rdef h(x):\rreturn x**8\rimport timeit\rprint(timeit.timeit(\u0026#39;[func(42) for func in (f,g,h)]\u0026#39;, globals=globals()))\r   参考 timeit - 测量小代码片段的执行时间\n ","description":"","id":25,"section":"posts","tags":["python"],"title":"Python timeit","uri":"https://Teletubby.github.io/zh/posts/python-timeit/"},{"content":" 我的 python 版本 是 3.7\n python sorted() (内置方法) 已收录在 python daily tips  译自: Python sorted()\n sorted() 函数以迭代方式返回排序列表。\nsorted() 函数以特定顺序（\u0026quot;升序\u0026ldquo;或\u0026rdquo;降序\u0026quot;）对给定的可迭代元素进行排序。\nsorted() 的语法是:\nsorted(iterable, key=None, reverse=False)\nsorted() 参数 sorted() 最多能接受三个参数\n iterable - 序列（字符串，元组，列表）或集合（集合，字典，冻结集合）或任何其他迭代器。 reverse (Optional) - 如果为 True ，则排序的列表会被反转（降序输出）。如果未说明，则表示默认 False。 key (Optional) - 用来作为比较排序的 key 的功能。默认为 None  示例 1: 对字符串、列表和元组进行排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14  # vowels list\r py_list = [\u0026#39;e\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;i\u0026#39;]\rprint(sorted(py_list))\r# [\u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;u\u0026#39;]\r # string  py_string = \u0026#39;Python\u0026#39;\rprint(sorted(py_string))\r# [\u0026#39;P\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;y\u0026#39;]\r # vowels tuple\r py_tuple = (\u0026#39;e\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;i\u0026#39;)\rprint(sorted(py_tuple))\r# [\u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;u\u0026#39;]\r   示例 2: 对集合(set)、字典(dict)和 frozenset 进行降序排序 sorted() 函数接受 reverse 参数作为可选参数。\n设置 reverse = True 将可迭代对象降序排序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  # set\r py_set = {\u0026#39;e\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;i\u0026#39;}\rprint(sorted(py_set, reverse = True))\r# [\u0026#39;u\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;a\u0026#39;]\r # dictionary\r py_dict = {\u0026#39;e\u0026#39;: 1, \u0026#39;a\u0026#39;: 2, \u0026#39;u\u0026#39;: 3, \u0026#39;o\u0026#39;: 4, \u0026#39;i\u0026#39;: 5}\rprint(sorted(py_dict, reverse = True))\r# [\u0026#39;u\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;a\u0026#39;]\r # frozen set\r frozen_set = frozenset((\u0026#39;e\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;i\u0026#39;))\rprint(sorted(frozen_set, reverse = True))\r# [\u0026#39;u\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;a\u0026#39;]\r   Python sorted() 中的 key 参数 sorted() 可以接受 key 函数 作为一个可选参数来实现自定义排序。\n根据 key 函数，可以对你给定的可迭代对象进行排序。\nEg.sorted(iterable, key=len)\n这样就可以对 iterable 根据其内部元素的长度进行从小到大进行排序。\n示例 3: 使用带 key 参数的 sorted() 对列表进行排序 1 2 3 4 5 6 7 8 9 10 11 12 13  # take the second element for sort\r def take_second(elem):\rreturn elem[1]\r# random list\r random = [(2, 2), (3, 4), (4, 1), (1, 3)]\r# sort list with key\r sorted_list = sorted(random, key = take_second)\r# print list\r print(\u0026#39;Sorted list:\u0026#39;, sorted_list)\r# Sorted list: [(4, 1), (2, 2), (1, 3), (3, 4)]\r   Note 还有一个和 sorted() 执行方式差不多的函数\u0026ndash; sort()。它们唯一的区别就是，sort() 方法不会返回任何值，并且会更改原始列表。\n","description":"","id":26,"section":"posts","tags":["python"],"title":"Python sorted()","uri":"https://Teletubby.github.io/zh/posts/python-sorted/"},{"content":"贝祖等式 这里只是简单的叙述 贝祖定理(裴蜀定理)。\n 参考 贝祖等式\n参考 裴蜀定理\n 对任何整数 a，b 和它们的最大公约数 d，关于未知数 x 和 y 的线性不定方程（称为裴蜀等式，亦贝祖等式）：若 a，b 是整数,且gcd(a,b)=d，那么对于任意的整数 x，y，ax + by都一定是 d 的倍数。\n特别地，一定存在整数 x，y 使 ax + by = d 成立。\n它的一个重要推论是：a，b 互质的充要条件是存在整数 x，y 使 ax + by = 1。\n在数论中，裴蜀等式（英语：Bézout\u0026rsquo;s identity）或裴蜀定理（Bézout\u0026rsquo;s lemma）是一个关于最大公约数（或最大公约式）的定理。裴蜀定理得名于法国数学家艾蒂安·裴蜀，说明了对任何整数 a、b 和 m，关于未知数 x 和 y 的线性丢番图方程（称为裴蜀等式）：\nax + by = m\n有解当且仅当 m 是 d 的倍数。裴蜀等式有解时必然有无穷多个整数解，每组解x、y都称为裴蜀数，可用辗转相除法求得 或 更相减损术。\n例如，12 和 42 的最大公因子是6，则方程 12x + 42y = 6 有解。事实上有 (-3)×12 + 1×42 = 6 及 4×12 + (-1）×42 = 6。\n裴蜀等式 也可以用来给最大公约数定义：d 其实就是最小的可以写成 ax + by 形式的正整数。这个定义的本质是整环中\u0026rdquo;理想\u0026ldquo;的概念。因此对于多项式整环也有相应的裴蜀定理。\n历史 历史上首先证明关于整数的裴蜀定理的并不是裴蜀，而是17世纪初的法国数学家克劳德-加斯帕·巴歇·德·梅齐里亚克。他在于1624年发表的著作《有关整数的令人快乐与惬意的问题集》（Problèmes plaisants et délectables qui se font par les nombres）第二版中给出了问题的描述和证明[1]。\n然而，裴蜀推广了梅齐里亚克的结论，特别是探讨了多项式中的裴蜀等式，并给出了相应的定理和证明[2]。\n注释 [1] 原版的网上版本（法文）\n[2] 证明的网上版本（法文）\n","description":"","id":27,"section":"posts","tags":["贝祖定理"],"title":"贝祖等式","uri":"https://Teletubby.github.io/zh/posts/math-bezu-identity/"},{"content":"LeetCode 67. 二进制求和 已收录在 my LeetCode 题目 给定两个二进制字符串，返回他们的和（用二进制表示）。\n输入为 非空 字符串且只包含数字 1 和 0。\n示例 输入: a = \u0026quot;11\u0026quot;, b = \u0026quot;1\u0026quot;\r输出: \u0026quot;100\u0026quot;\r输入: a = \u0026quot;1010\u0026quot;, b = \u0026quot;1011\u0026quot;\r输出: \u0026quot;10101\u0026quot;\r题解 方法一 内置 gcd 函数 无需多说，哈哈哈 😂\n代码实现 1 2 3  class Solution:\rdef addBinary(self, a: str, b: str) -\u0026gt; str:\rreturn bin(int(a, 2) + int(b, 2))[2:]\r  方法二 哈希表 用 哈希表.\n 两个输入串a, b中，将短串 左填充 \u0026lsquo;0\u0026rsquo; 直到长度和另一个串一样多。 创建一个 哈希表 用来记录这两个二进制串按位相加的结果的所有情况。表中每个键都有三个字符，从左到右分别表示 a中的字符，b中的字符和上一位的进位 (carry)。每个键的值有两个字符，分别表示当前位的运算结果 (ch) 和进位 (carry)。 ans += ch 并且将 ans 逆序 return。  代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class Solution:\rdef addBinary(self, a: str, b: str) -\u0026gt; str:\ralen = len(a)\rblen = len(b)\rif alen \u0026gt; blen:\rb = b.zfill(alen)\relse:\ra = a.zfill(blen)\rans = \u0026#39;\u0026#39;\rcarry = \u0026#39;0\u0026#39;\rhm = {\r\u0026#39;000\u0026#39; : (\u0026#39;0\u0026#39;, \u0026#39;0\u0026#39;),\r\u0026#39;101\u0026#39; : (\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;),\r\u0026#39;011\u0026#39; : (\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;),\r\u0026#39;110\u0026#39; : (\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;),\r\u0026#39;001\u0026#39; : (\u0026#39;1\u0026#39;, \u0026#39;0\u0026#39;),\r\u0026#39;100\u0026#39; : (\u0026#39;1\u0026#39;, \u0026#39;0\u0026#39;),\r\u0026#39;010\u0026#39; : (\u0026#39;1\u0026#39;, \u0026#39;0\u0026#39;),\r\u0026#39;111\u0026#39; : (\u0026#39;1\u0026#39;, \u0026#39;1\u0026#39;),\r\u0026#39; 0\u0026#39; : (\u0026#39;\u0026#39;, \u0026#39;\u0026#39;),\r\u0026#39; 1\u0026#39; : (\u0026#39;1\u0026#39;, \u0026#39;\u0026#39;)\r}\rfor ach,bch in zip(a[::-1] + \u0026#39; \u0026#39;, b[::-1] + \u0026#39; \u0026#39;):\rtmp = ach + bch + carry\rch, carry = hm[tmp]\rans += ch\rreturn ans[::-1]\r  复杂度分析  时间复杂度: O(N) 空间复杂度: O(N)  方法三 稍微改进 我们都知道 Python 中的字符串是一个 不可变对象。其所指对象的值是不能被修改的。\n因此如果你重新给它赋值，它将会创建一个新的字符串对象。这样的话，执行效率会有一定程度的降低。\n所以下面这段代码在方法二的基础上做了一点修改，将 carry 的初始值改为 ''，并且当进位为 ‘0’ 时也改为 ''。\n这样代码的运行速度可能会少有提高。\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Solution:\rdef addBinary(self, a: str, b: str) -\u0026gt; str:\ralen = len(a)\rblen = len(b)\rif alen \u0026gt; blen:\rb = b.zfill(alen)\relse:\ra = a.zfill(blen)\rcarry = ans = \u0026#39;\u0026#39;\rhm = {\r\u0026#39;00\u0026#39; : (\u0026#39;0\u0026#39;, \u0026#39;\u0026#39;),\r\u0026#39;101\u0026#39; : (\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;),\r\u0026#39;011\u0026#39; : (\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;),\r\u0026#39;11\u0026#39; : (\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;),\r\u0026#39;001\u0026#39; : (\u0026#39;1\u0026#39;, \u0026#39;\u0026#39;),\r\u0026#39;10\u0026#39; : (\u0026#39;1\u0026#39;, \u0026#39;\u0026#39;),\r\u0026#39;01\u0026#39; : (\u0026#39;1\u0026#39;, \u0026#39;\u0026#39;),\r\u0026#39;111\u0026#39; : (\u0026#39;1\u0026#39;, \u0026#39;1\u0026#39;),\r\u0026#39; \u0026#39; : (\u0026#39;\u0026#39;, \u0026#39;\u0026#39;),\r\u0026#39; 1\u0026#39; : (\u0026#39;1\u0026#39;, \u0026#39;\u0026#39;)\r}\rfor ach,bch in zip(a[::-1] + \u0026#39; \u0026#39;, b[::-1] + \u0026#39; \u0026#39;):\rtmp = ach + bch + carry\rch, carry = hm[tmp]\rans += ch\rreturn ans[::-1]\r  复杂度分析  时间复杂度: O(N) 空间复杂度: O(N)  ","description":"","id":28,"section":"posts","tags":["哈希表","leetCodeEasy"],"title":"LeetCode 67","uri":"https://Teletubby.github.io/zh/posts/leetcode-67/"},{"content":"LeetCode 面试题 01.06. 字符串压缩 已收录在 my LeetCode 题目 字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。\n比如，字符串aabcccccaaa会变为a2b1c5a3。若\u0026quot;压缩\u0026quot;后的字符串没有变短，则返回原先的字符串。\n你可以假设字符串中只包含大小写英文字母（a至z）。\n示例 输入：\u0026quot;aabcccccaaa\u0026quot;\r输出：\u0026quot;a2b1c5a3\u0026quot;\r输入：\u0026quot;abbccd\u0026quot;\r输出：\u0026quot;abbccd\u0026quot;\r解释：\r\u0026quot;abbccd\u0026quot; 压缩后为\u0026quot;a1b2c2d1\u0026quot;，比原字符串长度更长。\r留意 字符串长度在[0, 50000]范围内。\n题解 使用 f-string 会更快。\n如果你还不清楚怎么用f-string，可以点击这里获取更多帮助。\n在for循环内部添加判断语句，比较 当前记录的字符的个数-1 charsCnt - 1 与 字符串S的一半串长 len(S) \u0026gt;\u0026gt; 1, 若大于则直接 return S。\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution:\rdef compressString(self, S: str) -\u0026gt; str:\rn = len(S)\rif n \u0026lt;= 2:\rreturn S\rcnt = charsCnt = 1\rchar = S[0]\rans = \u0026#39;\u0026#39;\rn = n \u0026gt;\u0026gt; 1\rfor ch in S[1:] + \u0026#39; \u0026#39;:\rif ch != char:\rans += f\u0026#34;{char}{cnt}\u0026#34;\rchar = ch\rcnt = 1\rcharsCnt += 1\relse:\rcnt += 1\rif charsCnt - 1 \u0026gt; n:\rreturn S\rreturn ans\r  ","description":"","id":29,"section":"posts","tags":["leetCodeEasy"],"title":"LeetCode 面试题 01.06","uri":"https://Teletubby.github.io/zh/posts/leetcode-interview-problems-0106/"},{"content":" 我的 python 版本 是 3.7\n f-string 已收录在 python daily tips  原文来自: sunxb10-Python格式化字符串f-string概览\n f-string 亦称为 格式化字符串常量 (formatted string literals)，是Python3.6新引入的一种字符串格式化方法，该方法源于 PEP 498 – Literal String Interpolation, 主要目的是使格式化字符串的操作更加简便。f-string 是一个以\u0026rsquo;f\u0026rsquo; 或 \u0026lsquo;F\u0026lsquo;为前缀的字符串 (就像 f\u0026rsquo;xxx\u0026rsquo; 或 F\u0026rsquo;xxx\u0026rsquo;)。需要替换的字段由大括号{}括起来。\nf-string在本质上并不是字符串常量，而是一个在运行时运算求值的表达式\nf-string在功能方面不逊于传统的 %-formatting 语句和 str.format() 函数，同时性能又优于二者，且使用起来也更加简洁明了，因此对于Python3.6及以后的版本，推荐使用f-string进行字符串格式化。\n常用方法 f-string用大括号 {} 表示被替换字段，其中直接填入替换内容：\n1 2 3 4 5 6 7 8 9 10 11  \u0026gt;\u0026gt;\u0026gt; name = \u0026#39;Eric\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;Hello, my name is {name}\u0026#39;\r\u0026#39;Hello, my name is Eric\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; number = 7\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;My lucky number is {number}\u0026#39;\r\u0026#39;My lucky number is 7\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; price = 19.99\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;The price of this book is {price}\u0026#39;\r\u0026#39;The price of this book is 19.99\u0026#39;\r  表达式求值与函数调用 f-string的大括号 {} 可以填入表达式或调用函数，Python会求出其结果并填入返回的字符串内：\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026gt;\u0026gt;\u0026gt; f\u0026#39;A total number of {24 * 8 + 4}\u0026#39;\r\u0026#39;A total number of 196\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;Complex number {(2 + 2j) / (2 - 3j)}\u0026#39;\r\u0026#39;Complex number (-0.15384615384615388+0.7692307692307692j)\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; name = \u0026#39;ERIC\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;My name is {name.lower()}\u0026#39;\r\u0026#39;My name is eric\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; import math\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;The answer is {math.log(math.pi)}\u0026#39;\r\u0026#39;The answer is 1.1447298858494002\u0026#39;\r  引号、反斜杠与大括号转义 引号  f-string大括号内所用的引号不能和大括号外的引号定界符冲突，可根据情况灵活切换 ' 和 \u0026quot;：  1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; f\u0026#39;I am {\u0026#34;Eric\u0026#34;}\u0026#39;\r\u0026#39;I am Eric\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;I am {\u0026#39;Eric\u0026#39;}\u0026#39;\rFile \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1\rf\u0026#39;I am {\u0026#39;Eric\u0026#39;}\u0026#39;\r^\rSyntaxError: invalid syntax\r   若 ' 和 \u0026quot; 不足以满足要求，还可以使用 ''' 和 \u0026quot;\u0026quot;\u0026quot;：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026gt;\u0026gt;\u0026gt; f\u0026#34;He said {\u0026#34;I\u0026#39;m Eric\u0026#34;}\u0026#34;\r File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1\rf\u0026#34;He said {\u0026#34;I\u0026#39;m Eric\u0026#34;}\u0026#34;\r ^\rSyntaxError: invalid syntax\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;He said {\u0026#34;I\u0026#39;m Eric\u0026#34;}\u0026#39;\r File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1\rf\u0026#39;He said {\u0026#34;I\u0026#39;m Eric\u0026#34;}\u0026#39;\r ^\rSyntaxError: invalid syntax\r\u0026gt;\u0026gt;\u0026gt; f\u0026#34;\u0026#34;\u0026#34;He said {\u0026#34;I\u0026#39;m Eric\u0026#34;}\u0026#34;\u0026#34;\u0026#34;\r\u0026#34;He said I\u0026#39;m Eric\u0026#34;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;\u0026#39;\u0026#39;He said {\u0026#34;I\u0026#39;m Eric\u0026#34;}\u0026#39;\u0026#39;\u0026#39;\r\u0026#34;He said I\u0026#39;m Eric\u0026#34;\r  反斜杠 大括号外的引号还可以使用 \\ 转义，但大括号内不能使用 \\ 转义：\n1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; f\u0026#39;\u0026#39;\u0026#39;He\\\u0026#39;ll say {\u0026#34;I\u0026#39;m Eric\u0026#34;}\u0026#39;\u0026#39;\u0026#39;\r\u0026#34;He\u0026#39;ll say I\u0026#39;m Eric\u0026#34;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;\u0026#39;\u0026#39;He\u0026#39;ll say {\u0026#34;I\\\u0026#39;m Eric\u0026#34;}\u0026#39;\u0026#39;\u0026#39;\rFile \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1\rSyntaxError: f-string expression part cannot include a backslash\r  大括号（花括号） f-string大括号外如果需要显示大括号，则应输入连续两个大括号 {{ 和 }}：\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; f\u0026#39;5 {\u0026#34;{stars}\u0026#34;}\u0026#39;\r\u0026#39;5 {stars}\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;{{5}} {\u0026#34;stars\u0026#34;}\u0026#39;\r\u0026#39;{5} stars\u0026#39;\r  注意 上面提到，f-string大括号内不能使用 \\ 转义。\n事实上不仅如此，f-string大括号内根本就不允许出现 \\。如果确实需要 \\，则应首先将包含 \\ 的内容用一个变量表示，再在f-string大括号内填入变量名：\n1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; f\u0026#34;newline: {ord(\u0026#39;\\n\u0026#39;)}\u0026#34;\rFile \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1\rSyntaxError: f-string expression part cannot include a backslash\r\u0026gt;\u0026gt;\u0026gt; newline = ord(\u0026#39;\\n\u0026#39;)\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;newline: {newline}\u0026#39;\r\u0026#39;newline: 10\u0026#39;\r  多行f-string f-string还可用于多行字符串：\n1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; name = \u0026#39;Eric\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; age = 27\r\u0026gt;\u0026gt;\u0026gt; f\u0026#34;Hello!\u0026#34; \\\r... f\u0026#34;I\u0026#39;m {name}.\u0026#34; \\\r... f\u0026#34;I\u0026#39;m {age}.\u0026#34;\r\u0026#34;Hello!I\u0026#39;m Eric.I\u0026#39;m 27.\u0026#34;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#34;\u0026#34;\u0026#34;Hello!\r... I\u0026#39;m {name}.\r... I\u0026#39;m {age}.\u0026#34;\u0026#34;\u0026#34;\r\u0026#34;Hello!\\nI\u0026#39;m Eric.\\nI\u0026#39;m 27.\u0026#34;\r  自定义格式：对齐、宽度、符号、补零、精度、进制等 f-string采用 {content:format} 设置字符串格式，其中 content 是替换并填入字符串的内容，可以是变量、表达式或函数等，format 是格式描述符。采用默认格式时不必指定 {:format}，如上面例子所示只写 {content} 即可。\n关于格式描述符的详细语法及含义可查阅Python官方文档，这里按使用时的先后顺序简要介绍常用格式描述符的含义与作用：\n对齐相关格式描述符    格式描述符 含义与作用     \u0026lt; 左对齐（字符串默认对齐方式）   \u0026gt; 右对齐（数值默认对齐方式）   ^ 居中    数字符号相关格式描述符    格式描述符 含义与作用     + 负数前加负号（-），正数前加正号（+）   - 负数前加负号（-），正数前不加任何符号（默认）   （空格） 负数前加负号（-），正数前加一个空格     注：仅适用于数值类型。\n 数字显示方式相关格式描述符    格式描述符 含义与作用     # 切换数字显示方式     注1：仅适用于数值类型。\n注2：# 对不同数值类型的作用效果不同，详见下表：\n    数值类型 不加#（默认） 加# 区别     二进制整数 \u0026lsquo;1111011\u0026rsquo; \u0026lsquo;0b1111011\u0026rsquo; 开头是否显示 0b   八进制整数 \u0026lsquo;173\u0026rsquo; \u0026lsquo;0o173\u0026rsquo; 开头是否显示 0o   十进制整数 \u0026lsquo;123\u0026rsquo; \u0026lsquo;123\u0026rsquo; 无区别   十六进制整数（小写字母） \u0026lsquo;7b\u0026rsquo; \u0026lsquo;0x7b\u0026rsquo; 开头是否显示 0x   十六进制整数（大写字母） \u0026lsquo;7B\u0026rsquo; \u0026lsquo;0X7B\u0026rsquo; 开头是否显示 0X    宽度与精度相关格式描述符    格式描述符 含义与作用     width 整数 width 指定宽度   0width 整数 width 指定宽度，开头的 0 指定高位用 0 补足宽度   width.precision 整数 width 指定宽度，整数 precision 指定显示精度     注1：0width 不可用于复数类型和非数值类型，width.precision 不可用于整数类型。\n注2：width.precision 用于不同格式类型的浮点数、复数时的含义也不同：用于 f、F、e、E 和 % 时 precision 指定的是小数点后的位数，用于 g 和 G 时 precision 指定的是有效数字位数（小数点前位数+小数点后位数）。\n注3：width.precision 除浮点数、复数外还可用于字符串，此时 precision 含义是只使用字符串中前 precision 位字符。\n  示例：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026gt;\u0026gt;\u0026gt; a = 123.456\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;a is {a:8.2f}\u0026#39;\r\u0026#39;a is 123.46\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;a is {a:08.2f}\u0026#39;\r\u0026#39;a is 00123.46\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;a is {a:8.2e}\u0026#39;\r\u0026#39;a is 1.23e+02\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;a is {a:8.2%}\u0026#39;\r\u0026#39;a is 12345.60%\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;a is {a:8.2g}\u0026#39;\r\u0026#39;a is 1.2e+02\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; s = \u0026#39;hello\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;s is {s:8s}\u0026#39;\r\u0026#39;s is hello \u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;s is {s:8.3s}\u0026#39;\r\u0026#39;s is hel \u0026#39;\r  千位分隔符相关格式描述符    格式描述符 含义与作用     , 使用,作为千位分隔符   _ 使用_作为千位分隔符     注1：若不指定 , 或 ，则f-string不使用任何千位分隔符，此为默认设置。\n注2：, 仅适用于浮点数、复数与十进制整数：对于浮点数和复数，, 只分隔小数点前的数位。\n注3： 适用于浮点数、复数与二、八、十、十六进制整数：对于浮点数和复数，_ 只分隔小数点前的数位；对于二、八、十六进制整数，固定从低位到高位每隔四位插入一个 _（十进制整数是每隔三位插入一个 _）。\n  示例：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026gt;\u0026gt;\u0026gt; a = 1234567890.098765\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;a is {a:f}\u0026#39;\r\u0026#39;a is 1234567890.098765\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;a is {a:,f}\u0026#39;\r\u0026#39;a is 1,234,567,890.098765\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;a is {a:_f}\u0026#39;\r\u0026#39;a is 1_234_567_890.098765\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; b = 1234567890\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;b is {b:_b}\u0026#39;\r\u0026#39;b is 100_1001_1001_0110_0000_0010_1101_0010\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;b is {b:_o}\u0026#39;\r\u0026#39;b is 111_4540_1322\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;b is {b:_d}\u0026#39;\r\u0026#39;b is 1_234_567_890\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;b is {b:_x}\u0026#39;\r\u0026#39;b is 4996_02d2\u0026#39;\r  格式类型相关格式描述符 基本格式类型\n   格式描述符 含义与作用 适用变量类型     s 普通字符串格式 字符串   b 二进制整数格式 整数   c 字符格式，按unicode编码将整数转换为对应字符 整数   d 十进制整数格式 整数   o 八进制整数格式 整数   x 十六进制整数格式（小写字母） 整数   X 十六进制整数格式（大写字母） 整数   e 科学计数格式，以 e 表示 ×10^ 浮点数、复数、整数（自动转换为浮点数）   E 与 e 等价，但以 E 表示 ×10^ 浮点数、复数、整数（自动转换为浮点数）   f 定点数格式，默认精度（precision）是6 浮点数、复数、整数（自动转换为浮点数）   F 与 f 等价，但将 nan 和 inf 换成 NAN 和 INF 浮点数、复数、整数（自动转换为浮点数）   g 通用格式，小数用 f，大数用 e 浮点数、复数、整数（自动转换为浮点数）   G 与 G 等价，但小数用 F，大数用 E 浮点数、复数、整数（自动转换为浮点数）   % 百分比格式，数字自动乘上100后按 f 格式排版，并加 % 后缀 浮点数、整数（自动转换为浮点数）    常用的特殊格式类型：标准库 datetime 给定的用于排版时间信息的格式类型，适用于 date、datetime 和 time 对象\n   格式描述符 含义 显示样例     %a 星期几（缩写） \u0026lsquo;Sun\u0026rsquo;   %A 星期几（全名） \u0026lsquo;Sunday\u0026rsquo;   %w 星期几（数字，0 是周日，6 是周六） \u0026lsquo;0\u0026rsquo;   %u 星期几（数字，1 是周一，7 是周日） \u0026lsquo;7\u0026rsquo;   %d 日（数字，以 0 补足两位） \u0026lsquo;07\u0026rsquo;   %b 月（缩写） \u0026lsquo;Aug\u0026rsquo;   %B 月（全名） \u0026lsquo;August\u0026rsquo;   %m 月（数字，以 0 补足两位） \u0026lsquo;08\u0026rsquo;   %y 年（后两位数字，以 0 补足两位） \u0026lsquo;14\u0026rsquo;   %Y 年（完整数字，不补零） \u0026lsquo;2014\u0026rsquo;   %H 小时（24小时制，以 0 补足两位） \u0026lsquo;23\u0026rsquo;   %I 小时（12小时制，以 0 补足两位） \u0026lsquo;11\u0026rsquo;   %p 上午/下午 \u0026lsquo;PM\u0026rsquo;   %M 分钟（以 0 补足两位） \u0026lsquo;23\u0026rsquo;   %S 秒钟（以 0 补足两位） \u0026lsquo;56\u0026rsquo;   %f 微秒（以 0 补足六位） \u0026lsquo;553777\u0026rsquo;   %z UTC偏移量（格式是 ±HHMM[SS]，未指定时区则返回空字符串） \u0026lsquo;+1030\u0026rsquo;   %Z 时区名（未指定时区则返回空字符串） \u0026lsquo;EST\u0026rsquo;   %j 一年中的第几天（以 0 补足三位） \u0026lsquo;195\u0026rsquo;   %U 一年中的第几周（以全年首个周日后的星期为第0周，以 0 补足两位） \u0026lsquo;27\u0026rsquo;   %w 一年中的第几周（以全年首个周一后的星期为第0周，以 0 补足两位） \u0026lsquo;28\u0026rsquo;   %V 一年中的第几周（以全年首个包含1月4日的星期为第1周，以 0 补足两位） \u0026lsquo;28\u0026rsquo;     综合示例  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  \u0026gt;\u0026gt;\u0026gt; a = 1234\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;a is {a:^#10X}\u0026#39; # 居中，宽度10位，十六进制整数（大写字母），显示0X前缀\r \u0026#39;a is 0X4D2 \u0026#39;\r\u0026gt;\u0026gt;\u0026gt; b = 1234.5678\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;b is {b:\u0026lt;+10.2f}\u0026#39; # 左对齐，宽度10位，显示正号（+），定点数格式，2位小数\r \u0026#39;b is +1234.57 \u0026#39;\r\u0026gt;\u0026gt;\u0026gt; c = 12345678\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;c is {c:015,d}\u0026#39; # 高位补零，宽度15位，十进制整数，使用,作为千分分割位\r \u0026#39;c is 000,012,345,678\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; d = 0.5 + 2.5j\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;d is {d:30.3e}\u0026#39; # 宽度30位，科学计数法，3位小数\r \u0026#39;d is 5.000e-01+2.500e+00j\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; import datetime\r\u0026gt;\u0026gt;\u0026gt; e = datetime.datetime.today()\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;the time is {e:%Y-%m-%d(%a) %H:%M:%S}\u0026#39; # datetime时间格式\r \u0026#39;the time is 2018-07-14 (Sat) 20:46:02\u0026#39;\r  lambda表达式 f-string大括号内也可填入lambda表达式，但lambda表达式的 : 会被f-string误认为是表达式与格式描述符之间的分隔符，为避免歧义，需要将lambda表达式置于括号 () 内：\n 示例：  1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; f\u0026#39;result is {lambda x: x ** 2 + 1 (2)}\u0026#39;\rFile \u0026#34;\u0026lt;fstring\u0026gt;\u0026#34;, line 1\r(lambda x)\r^\rSyntaxError: unexpected EOF while parsing\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;result is {(lambda x: x ** 2 + 1) (2)}\u0026#39;\r\u0026#39;result is 5\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; f\u0026#39;result is {(lambda x: x ** 2 + 1) (2):\u0026lt;+7.2f}\u0026#39;\r\u0026#39;result is +5.00 \u0026#39;\r  参考文档   Python格式化字符串f-string概览 Python Documentation – Formatted String Literals Python Documentation – Format String Syntax PEP 498 – Literal String Interpolation Python 3’s f-Strings: An Improved String Formatting Syntax (Guide) python3 f-string格式化字符串的高级用法 Python 3: An Intro to f-strings   ","description":"","id":30,"section":"posts","tags":["python"],"title":"Python f-string","uri":"https://Teletubby.github.io/zh/posts/python-f-string/"},{"content":"LeetCode 409. 最长回文串 已收录在 my LeetCode 题目 给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。\n在构造过程中，请注意区分大小写。比如 \u0026ldquo;Aa\u0026rdquo; 不能当做一个回文字符串。\n示例 输入:\u0026quot;abccccdd\u0026quot;\r输出:7\r解释: 我们可以构造的最长的回文串是\u0026quot;dccaccd\u0026quot;, 它的长度是 7。\r留意 假设字符串的长度不会超过 1010。\n题解 方法一 在回文串的最中间可以有奇数字母[2]。\n因此先使用 collections.Counter 创建一个字典（dict）哈希表，来记录各个字母的数量。\n遍历哈希表，如果该字母为偶数字母[1]，cnt += Counter[letter].value()，否则 cnt += Counter[letter].value() - 1(为了保证添加的字母都是偶数个，可以构成回文串)，然后 cnt += 1。\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution:\rdef longestPalindrome(self, s: str) -\u0026gt; int:\rht = collections.Counter(s)\rflag = cnt = 0\rfor i in ht:\rval = ht[i]\rif val \u0026amp; 1 == 0:\rcnt += val\relse:\rcnt += val - 1\rflag = 1\rif flag:\rcnt += 1\rreturn cnt\r  方法二 另一种方法，我们可以反过来计算。\n用输入字符串的长度 len(s) 减去 oddCnt (*奇数字母[2]*的个数)，然后再加上 1 (如果 oddCnt \u0026gt; 0)。\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution:\rdef longestPalindrome(self, s: str) -\u0026gt; int:\r#2\r ht = collections.Counter(s)\rflag = oddCnt = 0\rfor i in ht:\rif ht[i] \u0026amp; 1 == 1:\roddCnt += 1\rflag = 1\rreturn len(s) - oddCnt + flag\r#1\r \u0026#39;\u0026#39;\u0026#39;\rht = collections.Counter(s)\rreturn len(s) - max(0,sum(ht[i]%2 for i in ht)-1)\r\u0026#39;\u0026#39;\u0026#39;\r  注解 [1]偶数字母：表示出现次数为偶数的字母。\n[2]奇数字母：表示出现次数为奇数的字母。\n注：仅限本文，后叙亦同\n","description":"","id":31,"section":"posts","tags":["哈希表","leetCodeEasy"],"title":"LeetCode 409","uri":"https://Teletubby.github.io/zh/posts/leetcode-409/"},{"content":" 我的 python 版本 是 3.7\n Python 中 collections.Counter() 的时间复杂度 正由 源码 所示, Counter 就是 字典 的子类. 构造它是 O(n), 因为对需要输入进行遍历，但是它对每个单元的操作仍是 O(1)。\n注意，从源码中还可以知道它在内部并没有保持一种有序的状态，而是通过最常见的输出方法（***__repr__***）进行简单的降序排序，并输出。\n 译自: StackOverflow-What is the time complexity of collections.Counter() in Python?\n ","description":"","id":32,"section":"posts","tags":["python"],"title":"Python collections.Counter 的时间复杂度","uri":"https://Teletubby.github.io/zh/posts/python-counter-time-complexity/"},{"content":" 我的 python 版本 是 3.7\n Python内置方法的时间复杂度 已收录在 python daily tips  译自 Python Wiki\n 本页面涵盖了Python中若干方法的 时间复杂度（或者叫\u0026quot;O\u0026rdquo;(大欧)）。该时间复杂度的计算基于当前 (最近一次由 JonathanHartley 编辑于 2017-06-05 19:58:18) 的CPython实现。其他Python的实现（包括老版本或者尚在开发的CPython实现）可能会在性能表现上有些许小小的差异，但一般不超过一个O(log n)。\n本文中，’n’代表容器中元素的数量，’k’代表参数的值，或者参数的数量。\n列表（list） 以随机数为参数生成的列表来表示平均情况\n列表是以 数组（Array） 实现的。最大的开销发生在超过当前分配大小的增长，这种情况下所有元素都需要移动；或者是在起始位置附近插入或者删除元素，这种情况下所有在该位置后面的元素都需要移动。如果你需要在一个队列的两端进行增删的操作，应当使用 collections.deque（双向队列）\n   操作 平均情况 最坏情况（平摊）     Copy O(n) O(n)   Append[1] O(1) O(1)   Pop last O(1) O(1)   Pop intermediate O(k) O(k)   Insert O(n) O(n)   Get Item O(1) O(1)   Set Item O(1) O(1)   Delete Item O(n) O(n)   Iteration O(n) O(n)   Get Slice O(k) O(k)   Del Slice O(n) O(n)   Set Slice O(k+n) O(k+n)   Extend[1] O(k) O(k)   Sort O(n log n) O(n log n)   Multiply O(nk) O(nk)   x in s O(n)    min(s), max(s) O(n)    Get Length O(1) O(1)    双向队列（collections.deque） deque （double-ended queue，双向队列）是以双向链表的形式实现的 (Well, a list of arrays rather than objects, for greater efficiency)。双向队列的两端都是可达的，但从查找队列中间的元素较为缓慢，增删元素就更慢了。\n   操作 平均情况 最坏情况（平摊）     Copy O(n) O(n)   append O(1) O(1)   appendleft O(1) O(1)   pop O(1) O(1)   popleft O(1) O(1)   extend O(k) O(k)   extendleft O(k) O(k)   rotate O(k) O(k)   remove O(n) O(n)    集合（set） 未列出的操作可参考 dict —— 二者的实现非常相似。\n   操作 平均情况 最坏情况 备注     x in s O(1) O(n)    Union s | t O(len(s)+len(t))     Intersection s\u0026amp;t O(min(len(s), len(t)) O(len(s) * len(t)) replace \u0026ldquo;min\u0026rdquo; with \u0026ldquo;max\u0026rdquo; if t is not a set   Multiple intersection s1\u0026amp;s2\u0026amp;..\u0026amp;sn  (n-1)*O(l) where l is max(len(s1),..,len(sn))    Difference s - t O(len(s))     s.difference_update(t) O(len(t))     Symmetric Difference s^t O(len(s)) O(len(s) * len(t))    s.symmetric_difference_update(t) O(len(t)) O(len(t) * len(s))      由源码得知，求差集（ s-t，或 s.difference(t) ）运算与更新为差集（ s.difference_uptate(t) ）运算的时间复杂度并不相同！前者是将在s中，但不在t中的元素添加到新的集合中，因此时间复杂度为O( len(s) )；后者是将在t中的元素从s中移除，因此时间复杂度为O( len(t) )。因此，使用时请留心，根据两个集合的大小以及是否需要新集合来选择合适的方法。\n集合的 s-t 运算中，并不要求t也一定是集合。只要 t 是可遍历的对象即可。\n 字典（dict） 表示平均情况：\n 对象的散列函数（哈希函数）足够撸棒（robust）或者说足够健壮，不会发生冲突。 字典的键是从所有可能的键的集合中随机选择的。\n注意 只使用字符串作为字典的键。这么做虽然不会影响算法的时间复杂度，但会对常数项产生显著的影响，这决定了你的一段程序能多快跑完。     操作 平均情况 最坏情况（平摊）     Copy[2] O(n) O(n)   Get Item O(1) O(n)   Set Item[1](更改元素) O(1) O(n)   Delete Item O(1) O(n)   Iteration[2] O(n) O(n)    注意 可能翻译有些词不达意😂\n[1] = 这些操作的时间复杂度取决于\u0026rdquo;最坏情况\u0026ldquo;的\u0026rdquo;平摊\u0026ldquo;部分。根据容器的历史记录，单个操作可能会花费很长的时间\n[2] = 对于这些操作，最坏的情况 n 是容器曾达到的最大值而不仅是当前值。例如先将N个对象添加到字典中，然后再删除N-1个，改字典仍需（至少）调整至N个对象的大小，直到下一次的插入操作完成。\n原文 [1] = These operations rely on the \u0026ldquo;Amortized\u0026rdquo; part of \u0026ldquo;Amortized Worst Case\u0026quot;. Individual actions may take surprisingly long, depending on the history of the container.\n[2] = For these operations, the worst case n is the maximum size the container ever achieved, rather than just the current size. For example, if N objects are added to a dictionary, then N-1 are deleted, the dictionary will still be sized for N objects (at least) until another insertion is made.\n","description":"","id":33,"section":"posts","tags":["python"],"title":"Python之时间复杂度","uri":"https://Teletubby.github.io/zh/posts/python-time-complexity/"},{"content":" 我的 python 版本 是 3.7\n Python3.7 中获取代码的几种方法  timeit \u0026ndash; 测量小代码片段的执行时间\n 方法一 1 2 3 4 5  import timeit\rstart=timeit.default_timer()\r#中间写代码块\r end=timeit.default_timer()\rprint(\u0026#39;Running time: %sSeconds\u0026#39;%(end-start))\r  此外 1 2  %timeit (1, 2, 3)\r# 7.87 ns ± 0.261 ns per loop (mean ± std. dev. of 7 runs, 100000000 loops each)\r   方法二 1 2 3 4 5  import time\rstart =time.time()\r#中间写上代码块\r end = time.time()\rprint(\u0026#39;Running time: %sSeconds\u0026#39;%(end-start))\r  方法三 1 2 3 4 5  import time\rstart =time.perf_counter()\r#中间写上代码块\r end = time.perf_counter()\rprint(\u0026#39;Running time: %sSeconds\u0026#39;%(end-start))\r  方法四 1 2 3 4 5 6  import time\rstart =time.process_time()\r#中间写上代码块\r end = time.process_time()\rprint(\u0026#39;Running time: %sSeconds\u0026#39;%(end-start))\r#默认精确到小数点后一位\r   ","description":"","id":34,"section":"posts","tags":["python"],"title":"Python 计算代码的运行时间","uri":"https://Teletubby.github.io/zh/posts/python-code-runtime/"},{"content":" 我的 python 版本 是 3.7\n Python for-else \u0026amp; while-else 语句 已收录在 python daily tips for-else 基本结构 这是for-else循环的基本结构：\n1 2 3 4 5 6 7 8  for item in container: if search_something(item): # 找到了! process(item) break else: # 没有找到任何东西。（for 循环正常遍历完） not_found_in_container()   说明 for-else 语句可能还有很多人不太熟悉，我也是在刷 LeetCode 的时候才看到的。其实容易理解，当你熟悉后这对你做题会有很大的帮助。\n 比如, LeetCode 1160. 拼写单词\n 常见的 for-else 的结构是在一个循环中寻找某个值。如果这个值找到了的话就会执行 break 跳出 for 循环，同时连着 else 一起跳出；或是到 for 循环结束时都没有找到需要的值，那么就会执行 else 语句。\nwhile-else 同样也有 while-else 语句，与 for-else 同理。\n 参考 https://book.pythontips.com/en/latest/for_-_else.html\n ","description":"","id":35,"section":"posts","tags":["python"],"title":"Python for-else 语句","uri":"https://Teletubby.github.io/zh/posts/python-for-else/"},{"content":"LeetCode 1160. 拼写单词 已收录在 my LeetCode 题目 给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。\n假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。\n注意：每次拼写（指拼写词汇表中的一个单词）时，chars 中的每个字母都只能用一次。\n返回词汇表 words 中你掌握的所有单词的 长度之和。\n示例 输入: words = [\u0026quot;cat\u0026quot;,\u0026quot;bt\u0026quot;,\u0026quot;hat\u0026quot;,\u0026quot;tree\u0026quot;], chars = \u0026quot;atach\u0026quot;\r输出: 6\r解释: 可以形成字符串 \u0026quot;cat\u0026quot; 和 \u0026quot;hat\u0026quot;，所以答案是 3 + 3 = 6。\r输入: words = [\u0026quot;hello\u0026quot;,\u0026quot;world\u0026quot;,\u0026quot;leetcode\u0026quot;], chars = \u0026quot;welldonehoneyr\u0026quot;\r输出: 10\r解释: 可以形成字符串 \u0026quot;hello\u0026quot; 和 \u0026quot;world\u0026quot;，所以答案是 5 + 5 = 10。\r留意  1 \u0026lt;= words.length \u0026lt;= 1000 1 \u0026lt;= words[i].length, chars.length \u0026lt;= 100 所有字符串中都仅包含小写英文字母  题解 方法一 哈希表 用 collections.Counter 来创建一个 哈希表 去比较 word 中与 chars 中的字母个数.\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution:\rdef countCharacters(self, words: List[str], chars: str) -\u0026gt; int:\r#1\r cnt = ans = 0\rtmp = hm = collections.Counter(chars)\rfor word in words:\rcnt = 0\rtmp = copy.copy(hm)\rfor ch in word:\rif ch in tmp and tmp[ch] \u0026gt; 0:\rcnt += 1\rtmp[ch] -= 1\relse:\rcnt = 0\rbreak\rans += cnt\rreturn ans\r  方法二 for-else 使用 for-else 语句，更加简洁。\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Solution:\rdef countCharacters(self, words: List[str], chars: str) -\u0026gt; int:\r#2.1\r #一个哈希表，比v2.0（后面那段代码）要快\r ans = 0\rht = collections.Counter(chars)\rfor word in words:\rfor ch in word:\rif ch not in ht or word.count(ch) \u0026gt; hm[ch]:\rbreak\relse:\rans += len(word)\rreturn ans\r#2.0\r #两个哈希表\r \u0026#39;\u0026#39;\u0026#39;\rchars_cnt = collections.Counter(chars)\rans = 0\rfor word in words:\rword_cnt = collections.Counter(word)\rfor c in word_cnt:\rif chars_cnt[c] \u0026lt; word_cnt[c]:\rbreak\relse:\rans += len(word)\rreturn ans\u0026#39;\r\u0026#39;\u0026#39;\u0026#39;\r  ","description":"","id":36,"section":"posts","tags":["哈希表","leetCodeEasy"],"title":"LeetCode 1160","uri":"https://Teletubby.github.io/zh/posts/leetcode-1160/"},{"content":"使用 Github 托管个人静态网站 已收录在 Hugo Blog 这个托管你个人博客的方法既简便又快捷。\n更改你的发布（publish）目录 删除 \u0026ldquo;public\u0026rdquo; 文件夹 如果你博客的 根目录 下有 \u0026ldquo;public\u0026rdquo; 文件夹的话，就把它先删掉。\nsudo rm -rf dd\n将 发布目录 改为 docs $ hugo --destination docs --gc server\n这条这令会在你博客的根目录下创建一个 \u0026ldquo;docs\u0026rdquo; 文件夹, 并且在本地启动 Hugo 服务器。\n\u0026ndash;gc 选项, 在构建后删除未使用的缓存文件。\n检查你的静态网站 启动 hugo 服务器后，可以通过命令行的提示去打开运行在本地的静态网站。\n如果没有什么错误的话, 继续下一步。\n创建一个公共仓库 注册 Github (如果已经有Github账号的话可以跳过这步) 注册 Github\n新建公共仓库 给仓库取个🐂🍺的名字, 之后你个人网站会像这样 https://用户名.github.io/仓库名/\n 如果你不知道怎么新建仓库, 点这\n 将你的 \u0026ldquo;docs\u0026rdquo; 文件夹 push 到仓库 创建一个 .gitignore 文件 在你的根文件夹 中创建 .gitignore 文件将更加方便执行 git push.\n 如果你不会创建，这个会对你有帮助\n git push 指令  如果不太清楚，点这里\n 🎉现在你的静态网站已经被托管到 Github 啦 相关  Git Commands \u0026amp; FAQ\nhugo host on Github\nGitHub Pages\n ","description":"","id":37,"section":"posts","tags":["hugo","github"],"title":"将Hugo托管在Github上","uri":"https://Teletubby.github.io/zh/posts/hugo-host-on-github/"},{"content":"已收录在 Hugo Blog (你想给你自己整一个静态网站吗?) 已收录在 Git Commands \u0026amp; FAQ git clone 这里有两种方法去使用 git clone\n1. 使用 HTTPS 这是一个克隆自己或者别人在 Github 上的仓库的一个简单的方法\ngit clone HTTPS(https://github.com/example.git)\n2. 使用 SSH 这个方法只能克隆自己已配置好的仓库，或者克隆别人已给你私钥的仓库\ngit clone SSH(git@github.com:example.git)\n给自己的仓库配置 SSH KEY $ ssh-keygen\r#生成 *rsa* 钥匙对\r#第一行选择 rsa 密钥的存储位置，回车即默认地址\r#对于 *Win10用户* 默认位置是/c/User/你的系统用户名/.ssh/id_rsa\r#后面两行输入两次密码，可以直接按两次回车\r$ cd ~/.ssh\r$ cat ~/.ssh/id_rsa.pub\r#查看你公钥的内容\r#将你的公钥复制粘贴到 *github* 或其他代码托管网站\r$ ssh -T git@github.com\r#检查与 Github 的连接\rgit push $ git init\r$ touch .gitignore\r$ vim .gitignore #输入需要被 *git add* 忽略的文件名或文件夹名\r$ git add . #或者 git add \u0026lt;文件名 or 文件夹名\u0026gt;\r$ git commit -m \u0026quot;第一次提交\u0026quot; #-m 选项, 添加此次 commit 的描述\r$ git remote add origin HTTPSorSSH\r#格式: git remote add \u0026lt;远程仓库名\u0026gt; \u0026lt;远程仓库的HTTPS或者SSH\u0026gt;\r$ git push -u origin master #远程仓库名为 origin\r#当前分支为 master\r#-u 选项, 设置默认的远程仓库名\r#下次push时，只需要输入\u0026quot;git push\u0026quot;\r可以输入\u0026quot;git push -h\u0026quot;获取更多帮助\n清空你 GitHub 上某个仓库的内容 $ git rm -rf *\r$ gir commit -m \u0026quot;清空仓库\u0026quot;\r$ git push -f\r","description":"","id":38,"section":"posts","tags":["git","github"],"title":"Git 基本指令 1","uri":"https://Teletubby.github.io/zh/posts/git-basic-commands-1/"},{"content":"已收录在 Hugo Blog (你想给你自己整一个静态网站吗?) 什么是 Git? Git是一个免费的开源的分布式版本控制系统工具，能够快速高效地处理从小型到大型项目的所有内容。\n 参考 https://git-scm.com/\n 下载 Git Windows\rLinux\rMacOS\r\rchoco install git.install\r#or\rscoop install git\r 如果你没有下载任何 包管理器 或者 下载器, 比如 choco, scoop 这些\n没关系, 点这下载Git\n\r下列以\u0026rdquo;#\u0026ldquo;开头的指令需要root权限. Ubuntu sudo apt-get install git\nFedora # dnf install git Fedora 22 and later\n# yum install git up to Fedora 21\nGentoo # emerge --ask --verbose dev-vcs/git\nArch Linux # pacman -S git\nopenSUSE # zypper install git\nMageia # urpmi git\nNix/NixOS # nix-env -i git\nFreeBSD # pkg install git\nSolaris 9/10/11 (OpenCSW) # pkgutil -i git\nSolaris 11 Express # pkg install developer/versioning/git\nOpenBSD # pkg_add git\nAlpine $ apk add git\nSlitaz $ tazpkg get-install git\n\rXcode 已经集成了 Git\n安装\u0026quot;Command Line Tools\u0026rdquo;(命令行工具)\r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"d6e338352578a5c7\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar tabLinks = null;\rvar tabContents = null;\rvar ids = [];\rif (containerElem) {\rtabLinks = containerElem.querySelectorAll('.tab__link');\rtabContents = containerElem.querySelectorAll('.tab__content');\r}\rfor (var i = 0; i 0) {\rtabContents[0].style.display = 'block';\r}\r 安装 \u0026amp; 配置 Git 如果你现在是 Win10 用户，并且下载的是个 .exe, 可执行文件 的话, 直接双击打开执行，一直点击 \u0026ldquo;next\u0026rdquo; 到安装完毕。\n检查是否安装成功，输入下面指令:\ngit version\n由于 Git 是一个分布式版本控制系统, 所以机器每次执行指令时都需要上报家门。像如下，给你的机器配置 userName 和 emailAddr :\n$ git config --global user.name \u0026quot;你的用户名\u0026quot;\r$ git config --global user.email \u0026quot;你的邮箱地址\u0026quot;\r 注意❗ 这个 git config 的 \u0026ndash;global 参数。使用这个 全局参数 的话，意味着在你机器上的所有 仓库 都会使用相同的配置，当然你也可以为你这些 仓库 配置其他不同的 用户名 和 电子邮箱。\n 查看帮助 Git 的基本指令:\nusage: git [--version] [--help] [-C \u0026lt;path\u0026gt;] [-c name=value]\r[--exec-path[=\u0026lt;path\u0026gt;]] [--html-path] [--man-path] [--info-path]\r[-p | --paginate | --no-pager] [--no-replace-objects] [--bare]\r[--git-dir=\u0026lt;path\u0026gt;] [--work-tree=\u0026lt;path\u0026gt;] [--namespace=\u0026lt;name\u0026gt;]\r\u0026lt;command\u0026gt; [\u0026lt;args\u0026gt;]\rThese are common Git commands used in various situations:\rstart a working area (see also: git help tutorial)\rclone Clone a repository into a new directory\rinit Create an empty Git repository or reinitialize an existing one\rwork on the current change (see also: git help everyday)\radd Add file contents to the index\rmv Move or rename a file, a directory, or a symlink\rreset Reset current HEAD to the specified state\rrm Remove files from the working tree and from the index\rexamine the history and state (see also: git help revisions)\rbisect Use binary search to find the commit that introduced a bug\rgrep Print lines matching a pattern\rlog Show commit logs\rshow Show various types of objects\rstatus Show the working tree status\rgrow, mark and tweak your common history\rbranch List, create, or delete branches\rcheckout Switch branches or restore working tree files\rcommit Record changes to the repository\rdiff Show changes between commits, commit and working tree, etc\rmerge Join two or more development histories together\rrebase Reapply commits on top of another base tip\rtag Create, list, delete or verify a tag object signed with GPG\rcollaborate (see also: git help workflows)\rfetch Download objects and refs from another repository\rpull Fetch from and integrate with another repository or a local branch\rpush Update remote refs along with associated objects\r'git help -a' and 'git help -g' list available subcommands and some\rconcept guides. See 'git help \u0026lt;command\u0026gt;' or 'git help \u0026lt;concept\u0026gt;'\rto read about a specific subcommand or concept.\r还是那句老话, 其实你所需要的就是在命令行中输入\u0026quot;git \u0026ndash;help\u0026rdquo;，然后查阅就行了。\n这里是 我的Git Commands \u0026amp; FAQ\n这里是 Git 官方指南\n已收录在 Hugo Blog ","description":"","id":39,"section":"posts","tags":["git","github"],"title":"安装 Git","uri":"https://Teletubby.github.io/zh/posts/install-git/"},{"content":"来白手建站吧，搭建一个hugo静态网站 已收录在 Hugo Blog 为什么选择 Hugo? \u0026amp; 什么是 Hugo? Hugo是一种用Go语言编写的快速的、现代静态网站生成器，为能够更有趣的创建网站而设计。 \u0026hellip;由于浏览网站的频率远远高于编辑网站，因此Hugo旨在为您的网站的终端用户提供最佳的浏览体验，并为网站作者提供理想的写作体验。\n 参考 https://gohugo.io/about/what-is-hugo/\n 简单的说: 快！很快！还简洁!清爽，爽歪歪的爽！\n开始吧! 安装 Hugo  参考官方文档 https://gohugo.io/getting-started/quick-start/\n Windows\rMacOS\rUbuntu\r\rchoco install hugo -confirm #or scoop install hugo \r brew install hugo \r sudo apt install hugo \r \r\r'use strict';\rvar containerId = JSON.parse(\"\\\"a41cd40346e4d5c0\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar tabLinks = null;\rvar tabContents = null;\rvar ids = [];\rif (containerElem) {\rtabLinks = containerElem.querySelectorAll('.tab__link');\rtabContents = containerElem.querySelectorAll('.tab__content');\r}\rfor (var i = 0; i 0) {\rtabContents[0].style.display = 'block';\r}\r 博主现在用的是 Win10系统,如果你不知道什么是 choco 或者 scoop 没事,直接下载已经编译好的可执行文件 .exe，下载好后直接将 .exe文件拖到命令行中，按回车执行即可，点此下载\n查看安装的Hugo版本:\nhugo version\n我的 Hugo 版本显示 Hugo Static Site Generator v0.66.0/extended windows/amd64 BuildDate: unknown ,emem\u0026hellip;简短就是 extended v0.66.0\n创建静态网站 如果你已经 安装 Git ,就直接在你想要创建网站的文件夹处右击 Git bash here。\n或者你也可以执行 cd 指令到那个文件夹, 然后输入如下指令：\n#format: hugo new site [path] [flags] hugo new site urSiteName 添加主题 首先安装 Git，然后从GitHub下载主题到你创建站点的子目录themes中：\n官方 Hugo 主题\n此博客的主题是 zzo, 你可以在主题作者的Github上 PR 并且给你的主题使用 git submodule 操作。\n如果你不清楚 Git 或者 GitHub 的基操, 请先 看看这 或者查阅 官方文档\ncd urSiteName #到你刚刚创建的文件夹中 git init git submodule add https://balabala.....git themes/themeName 试一手 ❗ 运行示例网站（demo） 从你的根目录（你创建站点的文件夹）中依次 themes/zzo/exampleSite 找到 exampleSite, 并在此目录下执行如下指令：\nhugo server --themesDir ../..\n配置主题并使用 你可以在那些主题页面上看到主题的说明文档，能够知道如何使用。这个 zzo主题 有自己专门的说明文档\n这些文档详细的说明了如何使用其主题，如何客制化主题等详细内容，值得一看。\n添加些内容 在你网站文件夹的根目录输入以下指令\nhugo new posts/hello-hugo.md\n.md 是一种 Markdown 文件, 应该使用 Markdown 语法去编辑, 如果你不知道，这是一本很好上手的 指南\n如果你知道怎么使用的话，那就开始动笔写点东西吧 ;-)\n--- title: \u0026quot;Hello Hugo\u0026quot; date: 2020-03-08T17:35:41+08:00 draft: true ---  ❗这个 .md 文件的 draft 属性 的初始状态是 true.\n 开启 hugo server 1.如果你没有将那文件的 draft 属性 改为 false, 那你也可以在启用 draft 的情况下启动 Hugo server :\nhugo server -D\n如果你的 端口：1313 处于可用状态，它会帮你布置到 http://localhost:1313/ ，否则会自动帮你找一个可用的端口并且搭建好。\n2.如果你已经将要发布的文章更改晚上且将 draft 属性 改为 false 的话。那就简单了，直接敲上：\nhugo server\n然后 按下回车 ，就好了。\n查看帮助 Hugo 的基本指令:\nhugo is the main command, used to build your Hugo site. Hugo is a Fast and Flexible Static Site Generator built with love by spf13 and friends in Go. Complete documentation is available at http://gohugo.io/. Usage: hugo [flags] hugo [command] Available Commands: config Print the site configuration convert Convert your content to different formats deploy Deploy your site to a Cloud provider. env Print Hugo version and environment info gen A collection of several useful generators. help Help about any command import Import your site from others. list Listing out various types of content mod Various Hugo Modules helpers. new Create new content for your site server A high performance webserver version Print the version number of Hugo Flags: -b, --baseURL string hostname (and path) to the root, e.g. http://spf13.com/ -D, --buildDrafts include content marked as draft -E, --buildExpired include expired content -F, --buildFuture include content with publishdate in the future --cacheDir string filesystem path to cache directory. Defaults: $TMPDIR/hugo_cache/ --cleanDestinationDir remove files from destination not found in static directories --config string config file (default is path/config.yaml|json|toml) --configDir string config dir (default \u0026quot;config\u0026quot;) -c, --contentDir string filesystem path to content directory --debug debug output -d, --destination string filesystem path to write files to --disableKinds strings disable different kind of pages (home, RSS etc.) --enableGitInfo add Git revision, date and author info to the pages -e, --environment string build environment --forceSyncStatic copy all files when static is changed. --gc enable to run some cleanup tasks (remove unused cache files) after the build -h, --help help for hugo --i18n-warnings print missing translations --ignoreCache ignores the cache directory --ignoreVendor ignores any _vendor directory -l, --layoutDir string filesystem path to layout directory --log enable Logging --logFile string log File path (if set, logging enabled automatically) --minify minify any supported output format (HTML, XML etc.) --noChmod don't sync permission mode of files --noTimes don't sync modification time of files --path-warnings print warnings on duplicate target paths etc. --quiet build in quiet mode --renderToMemory render to memory (only useful for benchmark testing) -s, --source string filesystem path to read files relative from --templateMetrics display metrics about template executions --templateMetricsHints calculate some improvement hints when combined with --templateMetrics -t, --theme strings themes to use (located in /themes/THEMENAME/) --themesDir string filesystem path to themes directory --trace file write trace to file (not useful in general) -v, --verbose verbose output --verboseLog verbose logging -w, --watch watch filesystem for changes and recreate as needed Additional help topics: hugo check Contains some verification checks Use \u0026quot;hugo [command] --help\u0026quot; for more information about a command. 事实上，你只需要在命令行中键入\u0026quot;hugo \u0026ndash;help\u0026rdquo;，然后查阅就行了。\n在下一篇，将 使用Github托管静态网站\n关于搭建 Hugo Blog 的所有 Blog 都收录在 Hugo Blog\n","description":"","id":40,"section":"posts","tags":["hugo"],"title":"你好 Hugo","uri":"https://Teletubby.github.io/zh/posts/hello-hugo/"},{"content":"已收录在 Git Commands \u0026amp; FAQ 解决 git pull/push 每次都需要输入密码问题（使用GitHub私有库） git bash到你需要操作的文件夹\ngit config --global credential.helper store\n然后再执行一次 git pull or git push，会提示输入账号和密码，之后就不需要了\n 在本地生成一个文本文件，记录着你刚刚输入的用户名和密码\n 博主现在用的是win10系统，文件在 C:\\Users\\你的系统用户名，叫 .git-credentials 里面内容如下:\nhttps://userName:userPasswd@github.com\n解决 GitHub error fatal: HttpRequestException encountered 执行后（承上所述），如果出现如下错误：\nerror fatal: HttpRequestException encountered\n可能是你的 Git Windows credential Manager 版本较低，需要下载新版本\n如果还是出现同样的错误，可能你需要更新 Git 版本，获取Git最新版本\n 参考 codeshare: How to solve the GitHub error fatal: HttpRequestException encountered\n ","description":"","id":41,"section":"posts","tags":["git","github"],"title":"解决 git pull/push 每次都需要输入密码问题（使用GitHub私有库）","uri":"https://Teletubby.github.io/zh/posts/store-github-username-and-passwd/"},{"content":"天线宝宝的博客  这个博客取名源于我和我女朋友，嘻嘻嘻😄\n 主题是 zzo❗\nPowered by Hugo\n","description":"关于","id":42,"section":"","tags":null,"title":"关 于","uri":"https://Teletubby.github.io/zh/about/"}]